var documenterSearchIndex = {"docs":
[{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"EditURL = \"../4_USDm_perp_trading.jl\"","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"Jupyter Notebook: 4_USDm_perp_trading.ipynb","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/#USD-M-perpetual-(Binance-style)-example","page":"USD-M perpetual trading","title":"USD-M perpetual (Binance-style) example","text":"","category":"section"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"This example shows how to backtest a USD-M perpetual swap using process_step! with mark updates and funding events. The CSV data is synthetic but shaped like Binance USD-M: hourly bid/ask/last prices and a funding rate applied every 8 hours (non-zero rows).","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"using Fastback\nusing Dates\nusing CSV\nusing DataFrames\nusing Statistics","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"# load synthetic USD-M perp data\n# columns: dt, bid, ask, last, funding_rate\n\ndata_path = \"../data/usdm_perp_1h.csv\";\n\n# if data path doesn't exist, try to change working directory\nisfile(data_path) || cd(\"src/examples\")\n\n# parse CSV (hourly rows)\ndf = DataFrame(CSV.File(data_path; dateformat=\"yyyy-mm-dd HH:MM:SS\"));\nsort!(df, :dt);\n\n# quick sanity check\nfirst(df, 5)","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"# create a margined account funded in USDT\nacc = Account(;\n    funding=AccountFunding.Margined,\n    base_currency=CashSpec(:USDT),\n    broker=BinanceBroker(; maker_derivatives=0.0004, taker_derivatives=0.0004),\n);\nusdt = cash_asset(acc, :USDT)\ndeposit!(acc, :USDT, 10_000.0);\n\n# register a USD-M perpetual (variation margin, cash-settled)\nperp = register_instrument!(\n    acc,\n    perpetual_instrument(\n        Symbol(\"BTCUSDT-PERP\"),\n        :BTC,\n        :USDT;\n        margin_requirement=MarginRequirement.PercentNotional,\n        margin_init_long=0.10,\n        margin_init_short=0.10,\n        margin_maint_long=0.05,\n        margin_maint_short=0.05,\n        base_tick=0.001,\n        quote_tick=0.1,\n        base_digits=3,\n        quote_digits=1,\n    ),\n);\n\n# data collector for account equity and drawdowns (sampling every hour)\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1));\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(1));\nnothing #hide","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"# simple trend-following strategy\n# - compute a 24h moving average\n# - go long if price is >0.2% above MA\n# - go short if price is >0.2% below MA\n# - target ~3x notional leverage\n\nwindow = 24;\ndeadband = 0.002;\nleverage_target = 3.0;\n\n@inline fill_price_for_qty(qty, bid, ask) = qty > 0.0 ? ask : bid\n\nfor i in 1:nrow(df)\n    row = df[i, :]\n    dt = row.dt\n    bid = row.bid\n    ask = row.ask\n    last = row.last\n    funding_rate = row.funding_rate\n\n    # apply marks and funding for this step\n    marks = [MarkUpdate(perp.index, bid, ask, last)]\n    funding = funding_rate == 0.0 ? nothing : [FundingUpdate(perp.index, funding_rate)]\n    process_step!(acc, dt; marks=marks, funding=funding, liquidate=true)\n\n    # trade after marks/funding (positions at funding timestamp are used)\n    if i >= window\n        ma = mean(@view df.last[i-window+1:i])\n        signal = last > (1 + deadband) * ma ? 1.0 : (last < (1 - deadband) * ma ? -1.0 : 0.0)\n\n        pos = get_position(acc, perp)\n        target_notional = signal == 0.0 ? 0.0 : signal * leverage_target * equity(acc, usdt)\n        target_qty = calc_base_qty_for_notional(perp, last, target_notional)\n        delta_qty = target_qty - pos.quantity\n\n        if abs(delta_qty) >= (perp.base_tick / 2)\n            fill_price = fill_price_for_qty(delta_qty, bid, ask)\n            order = Order(oid!(acc), perp, dt, fill_price, delta_qty)\n            fill_order!(acc, order; dt=dt, fill_price=fill_price, bid=bid, ask=ask, last=last)\n        end\n    end\n\n    # collect data for plotting\n    if should_collect(equity_data, dt)\n        eq = equity(acc, usdt)\n        collect_equity(dt, eq)\n        collect_drawdown(dt, eq)\n    end\nend\n\n# close any remaining position at the end\nrow = df[end, :]\npos = get_position(acc, perp)\nif pos.quantity != 0.0\n    close_qty = -pos.quantity\n    close_fill_price = fill_price_for_qty(close_qty, row.bid, row.ask)\n    order = Order(oid!(acc), perp, row.dt, close_fill_price, close_qty)\n    fill_order!(acc, order; dt=row.dt, fill_price=close_fill_price, bid=row.bid, ask=row.ask, last=row.last)\nend\n\n# summarize funding P&L\nfunding_pnl = sum(cf.amount for cf in acc.cashflows if cf.kind == CashflowKind.Funding)\nprintln(\"Funding P&L (USDT): \", round(funding_pnl, digits=2))\n\n# fill-level P&L decomposition (variation margin)\ngross_fill_settled_pnl = sum(t.fill_pnl_settle for t in acc.trades; init=0.0)\ncommissions = sum(t.commission_settle for t in acc.trades; init=0.0)\nnet_fill_cash = sum(t.cash_delta_settle for t in acc.trades; init=0.0)\nprintln(\"Gross fill settled P&L (USDT): \", round(gross_fill_settled_pnl, digits=2))\nprintln(\"Commissions (USDT): \", round(commissions, digits=2))\nprintln(\"Net fill cash delta (USDT): \", round(net_fill_cash, digits=2))\n\n# print account summary\nshow(acc)","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/#Plot-account-equity-curve","page":"USD-M perpetual trading","title":"Plot account equity curve","text":"","category":"section"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"using Plots\n\ntheme(:juno)\n\nFastback.plot_equity(equity_data; size=(800, 400))","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/#Plot-account-equity-drawdown-curve","page":"USD-M perpetual trading","title":"Plot account equity drawdown curve","text":"","category":"section"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"Fastback.plot_drawdown(drawdown_data; size=(800, 200))","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"","category":"page"},{"location":"examples/gen/4_USDm_perp_trading/#Plot-cashflows-by-type","page":"USD-M perpetual trading","title":"Plot cashflows by type","text":"","category":"section"},{"location":"examples/gen/4_USDm_perp_trading/","page":"USD-M perpetual trading","title":"USD-M perpetual trading","text":"Fastback.plot_cashflows(acc)","category":"page"},{"location":"pitfalls/#Pitfalls-and-gotchas","page":"Pitfalls and gotchas","title":"Pitfalls and gotchas","text":"","category":"section"},{"location":"pitfalls/","page":"Pitfalls and gotchas","title":"Pitfalls and gotchas","text":"AccountFunding.FullyFunded forces full-notional margin (no leverage), disallows short exposure, and uses liquidation marks for margin checks so bid/ask spreads do not create synthetic deficits.\nFor MarginRequirement.PercentNotional, margin rates are equity fractions (IMR/MMR style), not collateral-inclusive ratios: configure a \"150% short collateral\" rule as 0.50, not 1.50.\nPrincipal-exchange spot short-sale proceeds are not automatically lend-eligible: accrue_interest! applies broker-defined short-proceeds rules (broker_short_proceeds_rates) to exclude proceeds from lend base and optionally apply a separate rebate.\nUse update_marks! to keep equity and margin in sync with prices.\nExpiry/liquidation helpers use stored side-aware quotes (last_bid/last_ask); keep marks updated with update_marks!.\nMulti-currency equity depends on ExchangeRates being updated.\nRegister non-base currencies via register_cash_asset!(acc, CashSpec(:EUR)).\nFor variation-margin instruments, fills immediately settle to the current mark basis: execution-to-mark (mark - fill) hits cash on the fill, and post-fill avg_settle_price is the mark. Trade-level additive fill amounts are fill_pnl_settle (gross) and cash_delta_settle (net of commission).\nOrderRejectError rejection semantics are mainly for fill_order!; expiry/liquidation helpers send close-only synthetic fills (fill_qty = -position_qty) with allow_inactive=true, so they do not hit incremental-margin rejection (inc_qty == 0).\nFastback currently has no separate bankruptcy state; forced closes can still leave negative balances/equity in stressed scenarios.\nThe package contains optionally loaded Plots.jl extension functions (some functions additionally require StatsPlots.jl).","category":"page"},{"location":"examples/gen/1_random_trading/","page":"Random trading","title":"Random trading","text":"EditURL = \"../1_random_trading.jl\"","category":"page"},{"location":"examples/gen/1_random_trading/","page":"Random trading","title":"Random trading","text":"Jupyter Notebook: 1_random_trading.ipynb","category":"page"},{"location":"examples/gen/1_random_trading/#Random-trading-strategy-example","page":"Random trading","title":"Random trading strategy example","text":"","category":"section"},{"location":"examples/gen/1_random_trading/","page":"Random trading","title":"Random trading","text":"This dummy example demonstrates how to backtest a simple random trading strategy using synthetic data generated in the script. The price series is a random walk with a drift of 0.1 and initial price 1000.","category":"page"},{"location":"examples/gen/1_random_trading/","page":"Random trading","title":"Random trading","text":"The strategy randomly buys or sells an instrument with a probability of 1%. Buy and sell orders use the same price series, implying a spread of 0. Each trade is executed at a commission of 0.1%. For the sake of illustration, only 75% of the order quantity is filled.","category":"page"},{"location":"examples/gen/1_random_trading/","page":"Random trading","title":"Random trading","text":"The account equity and drawdowns are collected for every hour and plotted at the end using the Plots package.","category":"page"},{"location":"examples/gen/1_random_trading/","page":"Random trading","title":"Random trading","text":"using Fastback\nusing Dates\nusing Random\n\n# set RNG seed for reproducibility\nRandom.seed!(42);\n\n# generate synthetic hourly price series\nN = 2_000;\nprices = 1000.0 .+ cumsum(randn(N) .+ 0.1);\ndts = map(x -> DateTime(2020, 1, 1) + Hour(x), 0:N-1);\n\n# create trading account with $10'000 start capital (margin-enabled for shorting)\nacc = Account(;\n    funding=AccountFunding.Margined,\n    base_currency=CashSpec(:USD),\n    broker=FlatFeeBroker(; pct=0.001), # 0.1% commission\n);\nusd = cash_asset(acc, :USD)\ndeposit!(acc, :USD, 10_000.0);\n\n# register a dummy instrument\nDUMMY = register_instrument!(acc, spot_instrument(Symbol(\"DUMMY/USD\"), :DUMMY, :USD))\n\n# data collector for account equity and drawdowns (sampling every hour)\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1));\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(1));\n\n# loop over price series\nfor (dt, price) in zip(dts, prices)\n    # randomly trade with 1% probability\n    if rand() < 0.01\n        quantity = rand() > 0.4 ? 1.0 : -1.0\n        order = Order(oid!(acc), DUMMY, dt, price, quantity)\n        fill_order!(acc, order; dt=dt, fill_price=price, bid=price, ask=price, last=price, fill_qty=0.75order.quantity)\n    end\n\n    # update position and account P&L\n    update_marks!(acc, DUMMY, dt, price, price, price)\n\n    # collect data for plotting\n    if should_collect(equity_data, dt)\n        equity_value = equity(acc, usd)\n        collect_equity(dt, equity_value)\n        collect_drawdown(dt, equity_value)\n    end\nend\n\n# print account summary\nshow(acc)","category":"page"},{"location":"examples/gen/1_random_trading/#Plot-account-equity-curve","page":"Random trading","title":"Plot account equity curve","text":"","category":"section"},{"location":"examples/gen/1_random_trading/","page":"Random trading","title":"Random trading","text":"using Plots\n\ntheme(:juno);\n\nFastback.plot_equity(equity_data, size=(800, 400))","category":"page"},{"location":"examples/gen/1_random_trading/#Plot-account-equity-drawdowns","page":"Random trading","title":"Plot account equity drawdowns","text":"","category":"section"},{"location":"examples/gen/1_random_trading/","page":"Random trading","title":"Random trading","text":"Fastback.plot_drawdown(drawdown_data, size=(800, 200),)","category":"page"},{"location":"examples/gen/1_random_trading/#Summary-performance-table","page":"Random trading","title":"Summary performance table","text":"","category":"section"},{"location":"examples/gen/1_random_trading/","page":"Random trading","title":"Random trading","text":"performance_summary_table(equity_data; periods_per_year=365 * 24)","category":"page"},{"location":"concepts/#Accounting-model-and-event-loop","page":"Accounting model and event loop","title":"Accounting model and event loop","text":"","category":"section"},{"location":"concepts/","page":"Accounting model and event loop","title":"Accounting model and event loop","text":"Fastback is an event-driven accounting engine. You feed it events (marks, FX, funding, expiries), and it updates balances, equity, and margin deterministically.","category":"page"},{"location":"concepts/#Core-objects-(quick-definitions)","page":"Accounting model and event loop","title":"Core objects (quick definitions)","text":"","category":"section"},{"location":"concepts/","page":"Accounting model and event loop","title":"Accounting model and event loop","text":"Account: the central ledger (cash, positions, trades, equity, margin, cashflows).\nCash: a funding currency (USD, EUR, BTC) with balances and equity tracked per symbol.\nInstrument: contract metadata (symbols, settlement, margin, lifecycle).\nOrder: intent to trade at a given time, price, quantity.\nTrade: realized fill produced by fill_order!.\nPosition: netted exposure per instrument with average entry price.","category":"page"},{"location":"concepts/#Balances-vs-equity","page":"Accounting model and event loop","title":"Balances vs equity","text":"","category":"section"},{"location":"concepts/","page":"Accounting model and event loop","title":"Accounting model and event loop","text":"Balance is cash-only. Deposits, withdrawals, commissions, and realized P&L change balances.\nEquity is balance plus unrealized P&L for open positions in that currency.\nupdate_marks! recalculates unrealized P&L and updates equity.\nFor variation-margin instruments, unrealized P&L is settled into cash on each mark, so balances move as well.\nPrincipal-exchange spot shorts increase cash balance by short-sale proceeds. Interest accrual can exclude those proceeds from the regular lend base and optionally apply a separate short-proceeds rebate rate via broker configuration.","category":"page"},{"location":"concepts/#Realized-vs-unrealized-P-and-L","page":"Accounting model and event loop","title":"Realized vs unrealized P&L","text":"","category":"section"},{"location":"concepts/","page":"Accounting model and event loop","title":"Accounting model and event loop","text":"Fill-level additive gross P&L is recorded on Trade as fill_pnl_settle.\nNet fill cash movement is cash_delta_settle.\nUnrealized P&L lives on the Position (pnl_quote, pnl_settle) and is mirrored into equity via update_marks! or process_step!.","category":"page"},{"location":"concepts/#Settlement-styles","page":"Accounting model and event loop","title":"Settlement styles","text":"","category":"section"},{"location":"concepts/","page":"Accounting model and event loop","title":"Accounting model and event loop","text":"PrincipalExchange: fills exchange principal; open position value is marked notional (qty * price * multiplier).\nVariationMargin: mark-to-market P&L is settled into cash at each mark; open position value stays at zero.","category":"page"},{"location":"concepts/","page":"Accounting model and event loop","title":"Accounting model and event loop","text":"AccountFunding.FullyFunded is a funding policy, not a settlement style.","category":"page"},{"location":"concepts/#Margin-requirements-and-styles","page":"Accounting model and event loop","title":"Margin requirements and styles","text":"","category":"section"},{"location":"concepts/","page":"Accounting model and event loop","title":"Accounting model and event loop","text":"Funding policies: AccountFunding.FullyFunded enforces fully funded exposure (full notional margin), disallows short exposure, prices requirements from liquidation marks (bid for longs, ask for shorts), and requires withdrawals to respect available funds; AccountFunding.Margined uses instrument margin settings, with margin priced from marks for VariationMargin instruments and from last-trade for other settlement styles.\nMargin requirements on instruments: PercentNotional, FixedPerContract.\nPercentNotional uses IMR/MMR-style equity fractions of notional: required_margin = rate * abs(qty) * abs(price) * multiplier.\nFor short rules expressed as total collateral (for example \"150% of short notional\"), convert to equity fraction before configuring Fastback: 150% -> 0.50.\nMargin aggregation: PerCurrency or BaseCurrency, controlling how margin totals are aggregated.","category":"page"},{"location":"concepts/#Event-loop","page":"Accounting model and event loop","title":"Event loop","text":"","category":"section"},{"location":"concepts/","page":"Accounting model and event loop","title":"Accounting model and event loop","text":"The engine is driven by explicit events.","category":"page"},{"location":"concepts/","page":"Accounting model and event loop","title":"Accounting model and event loop","text":"A typical loop is:","category":"page"},{"location":"concepts/","page":"Accounting model and event loop","title":"Accounting model and event loop","text":"Advance time (enforced non-decreasing timestamps): advance_time!.\nAccrue interest and borrow fees as needed: accrue_interest!, accrue_borrow_fees!.\nApply FX updates if you run multi-currency: update_rate! (or process_step! with FXUpdate).\nMark positions with bid/ask/last prices: update_marks!.\nApply funding events (perpetuals): apply_funding!.\nProcess expiries (futures): process_expiries!.\nOptionally liquidate to maintenance: liquidate_to_maintenance!.\nDecide and fill new orders for that step: fill_order! (after Order creation).","category":"page"},{"location":"concepts/","page":"Accounting model and event loop","title":"Accounting model and event loop","text":"You can either:","category":"page"},{"location":"concepts/","page":"Accounting model and event loop","title":"Accounting model and event loop","text":"Use process_step! to run steps 1-7 in one call (recommended for clean, deterministic loops).\nCall the individual functions manually when you need custom ordering.","category":"page"},{"location":"concepts/","page":"Accounting model and event loop","title":"Accounting model and event loop","text":"The How-to page shows both styles with code snippets.","category":"page"},{"location":"examples/gen/3_multi_currency/","page":"Multi-Currency trading","title":"Multi-Currency trading","text":"EditURL = \"../3_multi_currency.jl\"","category":"page"},{"location":"examples/gen/3_multi_currency/","page":"Multi-Currency trading","title":"Multi-Currency trading","text":"Jupyter Notebook: 3_multi_currency.ipynb","category":"page"},{"location":"examples/gen/3_multi_currency/#Multi-currency-trading-example","page":"Multi-Currency trading","title":"Multi-currency trading example","text":"","category":"section"},{"location":"examples/gen/3_multi_currency/","page":"Multi-Currency trading","title":"Multi-Currency trading","text":"This example demonstrates how to trade assets quoted in different currencies. The account has balances in USD, EUR and GBP, and trades stocks denoted in those currencies. The total equity is calculated in USD. A spot exchange rate helper is used to convert between different currencies.","category":"page"},{"location":"examples/gen/3_multi_currency/","page":"Multi-Currency trading","title":"Multi-Currency trading","text":"using Fastback\nusing Dates\nusing Random\nusing DataFrames\n\n# set RNG seed for reproducibility\nRandom.seed!(42);\n\n# generate synthetic hourly price series for Tesla (USD), Porsche (EUR) and Tesco (GBP)\nN = 2_000;\ndf = DataFrame([\n    :date => map(x -> DateTime(2020, 1, 1) + Hour(x), 0:N-1),\n    :TSLA => 170 .+ cumsum(randn(N) .+ 0.12),\n    :POAHY => 4.5 .+ cumsum(randn(N) .+ 0.02),\n    :TSCO_L => 307 .+ cumsum(randn(N) .+ 0.08)\n]);\n\n# create trading account with 10'000 USD, 5'000 EUR and 20'000 GBP cash (margin-enabled for shorting)\ner = ExchangeRates();\nacc = Account(;\n    funding=AccountFunding.Margined,\n    base_currency=CashSpec(:USD),\n    exchange_rates=er,\n    broker=FlatFeeBroker(; pct=0.001),\n);\nusd = cash_asset(acc, :USD)\neur = register_cash_asset!(acc, CashSpec(:EUR; digits=2));\ngbp = register_cash_asset!(acc, CashSpec(:GBP; digits=2));\ndeposit!(acc, usd, 10_000);\ndeposit!(acc, eur, 5_000);\ndeposit!(acc, gbp, 20_000);\n\n# set spot exchange rates once\nupdate_rate!(er, eur, usd, 1.07);\nupdate_rate!(er, gbp, usd, 1.27);\n\nshow(er)\n\n# register stock instruments\ninstruments = [\n    register_instrument!(acc, spot_instrument(:TSLA, :TSLA, :USD)), # Tesla (USD denominated)\n    register_instrument!(acc, spot_instrument(:POAHY, :POAHY, :EUR)), # Porsche (EUR denominated)\n    register_instrument!(acc, spot_instrument(:TSCO_L, :TSCO_L, :GBP)), # Tesco (GBP denominated)\n];\n\n# data collector for account equity and drawdowns (sampling every hour)\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1));\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(1));\n\n# loop over price series\nfor i in 1:N\n    dt = df.date[i]\n\n    # randomly trade with 1% probability\n    if rand() < 0.01\n        inst = rand(instruments)\n        price = df[i, inst.symbol]\n        quantity = rand() > 0.5 ? 10.0 : -10.0\n        order = Order(oid!(acc), inst, dt, price, quantity)\n        fill_order!(acc, order; dt=dt, fill_price=price, bid=price, ask=price, last=price)\n    end\n\n    # update position and account P&L\n    for inst in instruments\n        price = df[i, inst.symbol]\n        update_marks!(acc, inst, dt, price, price, price)\n    end\n\n    # collect data for plotting\n    if should_collect(equity_data, dt)\n        total_equity = (\n            equity(acc, usd) +\n            equity(acc, eur) * get_rate(er, eur, usd) +\n            equity(acc, gbp) * get_rate(er, gbp, usd)\n        )\n        collect_equity(dt, total_equity)\n        collect_drawdown(dt, total_equity)\n    end\nend\n\n# print account summary\nshow(acc)","category":"page"},{"location":"examples/gen/3_multi_currency/#Plot-account-equity-curve","page":"Multi-Currency trading","title":"Plot account equity curve","text":"","category":"section"},{"location":"examples/gen/3_multi_currency/","page":"Multi-Currency trading","title":"Multi-Currency trading","text":"using Plots\n\ntheme(:juno)\n\n# plot equity curve\nFastback.plot_equity(equity_data; size=(800, 400))","category":"page"},{"location":"examples/gen/3_multi_currency/#Plot-account-equity-drawdown-curve","page":"Multi-Currency trading","title":"Plot account equity drawdown curve","text":"","category":"section"},{"location":"examples/gen/3_multi_currency/","page":"Multi-Currency trading","title":"Multi-Currency trading","text":"# plot drawdown curve\nFastback.plot_drawdown(drawdown_data; size=(800, 200))","category":"page"},{"location":"basic_setup/#Fastback-basic-backtest-setup","page":"Basic setup","title":"Fastback basic backtest setup","text":"","category":"section"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"A backtest using Fastback usually consists of the following parts:","category":"page"},{"location":"basic_setup/#1.-Data","page":"Basic setup","title":"1. Data","text":"","category":"section"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"Acquire data like price, volume and other features you want to backtest on. This can be from a DataFrame, a CSV file, or a database. Ideally, it can be looped over or streamed efficiently.","category":"page"},{"location":"basic_setup/#2.-Account","page":"Basic setup","title":"2. Account","text":"","category":"section"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"Initialize the account you want to backtest with. The account holds the assets (funds), positions, trades, and does all the bookkeeping. Create Account first, then register additional cash assets on the account:","category":"page"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"er = ExchangeRates()\naccount = Account(;\n    broker=FlatFeeBroker(pct=0.001),\n    funding=AccountFunding.Margined,\n    base_currency=CashSpec(:USD),\n    exchange_rates=er,\n)\nusd = cash_asset(account, :USD)\neur = register_cash_asset!(account, CashSpec(:EUR; digits=2)) # optional","category":"page"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"Fund the account with deposit!(account, usd, amount). For non-base currencies, use their registered Cash handles, e.g. deposit!(account, eur, amount). Use withdraw!(account, usd, amount) later when simulating outflows.","category":"page"},{"location":"basic_setup/#3.-Instruments","page":"Basic setup","title":"3. Instruments","text":"","category":"section"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"Register the instruments you want to trade with, e.g. stocks or cryptocurrencies. Instruments specify the display symbol, base- and quote symbols, tick sizes and valid value ranges.","category":"page"},{"location":"basic_setup/#4.-Data-collectors","page":"Basic setup","title":"4. Data collectors","text":"","category":"section"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"Initialize data collectors for account balance, equity, drawdowns, etc. Data collectors are not required, but help in collecting data for further analysis of the backtest results.","category":"page"},{"location":"basic_setup/#5.-Trading-logic","page":"Basic setup","title":"5. Trading logic","text":"","category":"section"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"Implement the actual trading logic you want to backtest, i.e. the strategy. It is called at every iteration of the input data and takes trading decisions like buying or selling instruments. In a live-setting, the data would be streamed to the trading logic instead of being looped over.","category":"page"},{"location":"basic_setup/#6.-Analysis","page":"Basic setup","title":"6. Analysis","text":"","category":"section"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"Analyze the backtest results by inspecting the account and the collected data. Print account balances, equity, drawdowns, etc., or create plots. Alternatively, store the results in a Vector or DataFrame for further analysis. For example, when running an optimization, we compute the metric of interest and store it in a Vector or similar. At the end of the optimization, we can then inspect the results and find the best parameters.","category":"page"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"For a runnable minimal example, see the Getting started page.","category":"page"},{"location":"integrations/gen/3_Timestamps64_integration/","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"EditURL = \"../3_Timestamps64_integration.jl\"","category":"page"},{"location":"integrations/gen/3_Timestamps64_integration/","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"Jupyter Notebook: 3_Timestamps64_integration.ipynb","category":"page"},{"location":"integrations/gen/3_Timestamps64_integration/#Timestamps64-integration-example","page":"Timestamps64.jl","title":"Timestamps64 integration example","text":"","category":"section"},{"location":"integrations/gen/3_Timestamps64_integration/","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"This example shows how to pair Fastback's timestamp parametrization with high-resolution Timestamp64 values from Timestamps64.jl.","category":"page"},{"location":"integrations/gen/3_Timestamps64_integration/","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"Timestamps64.jl provides nanosecond-resolution timestamps based on Int64 values, which makes them very efficient in terms of memory and performance. They are particularly useful for high-frequency trading applications. Compared to NanoDates.jl, Timestamps64.jl has a smaller memory footprint (8 bytes vs. 16 bytes), and is faster for arithmetic operations.","category":"page"},{"location":"integrations/gen/3_Timestamps64_integration/","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"This example is derived from the random trading walkthrough but focuses on exercising the integration, so plotting has been omitted.","category":"page"},{"location":"integrations/gen/3_Timestamps64_integration/","page":"Timestamps64.jl","title":"Timestamps64.jl","text":"using Fastback\nusing Dates\nusing Timestamps64\nusing Random\n\n# set RNG seed for reproducibility\nRandom.seed!(42);\n\n# generate synthetic price series\nN = 2_000\nprices = 1000.0 .+ cumsum(randn(N) .+ 0.1)\nstart_dt = Timestamp64(2020, 1, 1)\ndts = [start_dt + Hour(i) for i in 0:N-1]\n\n# create trading account with $10'000 start capital and Timestamp64 support (margin-enabled for shorting)\nacc = Account(;\n    time_type=Timestamp64,\n    funding=AccountFunding.Margined,\n    base_currency=CashSpec(:USD),\n    broker=FlatFeeBroker(; pct=0.001),\n)\nusd = cash_asset(acc, :USD)\ndeposit!(acc, :USD, 10_000.0)\n\n# register a dummy instrument\nDUMMY = register_instrument!(acc, spot_instrument(Symbol(\"DUMMY/USD\"), :DUMMY, :USD; time_type=Timestamp64))\n\n# data collector for account equity and drawdowns (sampling every hour)\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1); time_type=Timestamp64)\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(1); time_type=Timestamp64)\n\n# loop over price series\nfor (dt, price) in zip(dts, prices)\n    # randomly trade with 1% probability\n    if rand() < 0.01\n        quantity = rand() > 0.4 ? 1.0 : -1.0\n        order = Order(oid!(acc), DUMMY, dt, price, quantity)\n        fill_order!(acc, order; dt=dt, fill_price=price, bid=price, ask=price, last=price, fill_qty=0.75order.quantity)\n    end\n\n    # update position and account P&L\n    update_marks!(acc, DUMMY, dt, price, price, price)\n\n    # collect data for analysis\n    if should_collect(equity_data, dt)\n        equity_value = equity(acc, usd)\n        collect_equity(dt, equity_value)\n        collect_drawdown(dt, equity_value)\n    end\nend\n\n# print account summary\nshow(acc)","category":"page"},{"location":"integrations/gen/1_Tables_integration/","page":"Tables.jl","title":"Tables.jl","text":"EditURL = \"../1_Tables_integration.jl\"","category":"page"},{"location":"integrations/gen/1_Tables_integration/","page":"Tables.jl","title":"Tables.jl","text":"Jupyter Notebook: 1_Tables_integration.ipynb","category":"page"},{"location":"integrations/gen/1_Tables_integration/#Tables.jl-integration-example","page":"Tables.jl","title":"Tables.jl integration example","text":"","category":"section"},{"location":"integrations/gen/1_Tables_integration/","page":"Tables.jl","title":"Tables.jl","text":"This example demonstrates the Tables.jl integration in Fastback by running a simple backtest and then converting account data to DataFrames for display.","category":"page"},{"location":"integrations/gen/1_Tables_integration/","page":"Tables.jl","title":"Tables.jl","text":"The Tables.jl interface provides zero-copy views of trades, positions, cash balances, equity balances, and collector output, making it easy to export results to DataFrames.jl, CSV.jl, Arrow.jl or any other package that consumes Tables-compatible sources.","category":"page"},{"location":"integrations/gen/1_Tables_integration/","page":"Tables.jl","title":"Tables.jl","text":"using Fastback\nusing DataFrames\nusing Dates\nusing Random\n\n# set RNG seed for reproducibility\nRandom.seed!(123);\n\n# generate synthetic price series\nN = 500;\nprices = 100.0 .+ cumsum(randn(N) .* 0.5 .+ 0.05);\ndts = map(x -> DateTime(2021, 1, 1) + Hour(x), 0:N-1);\n\n# create trading account with $5'000 start capital (margin-enabled for shorting)\nacc = Account(;\n    funding=AccountFunding.Margined,\n    base_currency=CashSpec(:USD),\n    broker=FlatFeeBroker(; pct=0.001),\n);\nusd = cash_asset(acc, :USD)\ndeposit!(acc, :USD, 5_000.0);\n\n# register instruments\nAAPL = register_instrument!(acc, spot_instrument(Symbol(\"AAPL/USD\"), :AAPL, :USD));\nMSFT = register_instrument!(acc, spot_instrument(Symbol(\"MSFT/USD\"), :MSFT, :USD));\n\n# data collectors\ncollect_equity, equity_data = periodic_collector(Float64, Hour(12));\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(12));\n\n# simple momentum strategy\nlet prev_price = prices[1]\n    for (i, (dt, price)) in enumerate(zip(dts, prices))\n        # trade every 10 hours based on price momentum\n        if i % 10 == 0 && i > 10\n            momentum = (price - prev_price) / prev_price\n\n            if momentum > 0.02  # buy signal\n                quantity = 10.0\n                order = Order(oid!(acc), AAPL, dt, price, quantity)\n                fill_order!(acc, order; dt=dt, fill_price=price, bid=price, ask=price, last=price)\n\n            elseif momentum < -0.02  # sell signal\n                quantity = -8.0\n                order = Order(oid!(acc), MSFT, dt, price, quantity)\n                fill_order!(acc, order; dt=dt, fill_price=price, bid=price, ask=price, last=price)\n            end\n\n            prev_price = price\n        end\n\n        # update positions P&L\n        update_marks!(acc, AAPL, dt, price, price, price)\n        update_marks!(acc, MSFT, dt, price, price, price)\n\n        # collect equity data\n        if should_collect(equity_data, dt)\n            equity_value = equity(acc, usd)\n            collect_equity(dt, equity_value)\n            collect_drawdown(dt, equity_value)\n        end\n    end\nend\n\n# print account summary\nshow(acc)","category":"page"},{"location":"integrations/gen/1_Tables_integration/#Convert-trades-to-DataFrame","page":"Tables.jl","title":"Convert trades to DataFrame","text":"","category":"section"},{"location":"integrations/gen/1_Tables_integration/","page":"Tables.jl","title":"Tables.jl","text":"df_trades = DataFrame(trades_table(acc))\n\nprintln(df_trades)","category":"page"},{"location":"integrations/gen/1_Tables_integration/#Convert-positions-to-DataFrame","page":"Tables.jl","title":"Convert positions to DataFrame","text":"","category":"section"},{"location":"integrations/gen/1_Tables_integration/","page":"Tables.jl","title":"Tables.jl","text":"df_positions = DataFrame(positions_table(acc))\n\nprintln(df_positions)","category":"page"},{"location":"integrations/gen/1_Tables_integration/#Convert-cash-balances-to-DataFrame","page":"Tables.jl","title":"Convert cash balances to DataFrame","text":"","category":"section"},{"location":"integrations/gen/1_Tables_integration/","page":"Tables.jl","title":"Tables.jl","text":"df_balances = DataFrame(balances_table(acc))\n\nprintln(df_balances)","category":"page"},{"location":"integrations/gen/1_Tables_integration/#Convert-equity-balances-to-DataFrame","page":"Tables.jl","title":"Convert equity balances to DataFrame","text":"","category":"section"},{"location":"integrations/gen/1_Tables_integration/","page":"Tables.jl","title":"Tables.jl","text":"df_equities = DataFrame(equities_table(acc))\n\nprintln(df_equities)","category":"page"},{"location":"integrations/gen/1_Tables_integration/#Convert-equity-collector-data-to-DataFrame","page":"Tables.jl","title":"Convert equity collector data to DataFrame","text":"","category":"section"},{"location":"integrations/gen/1_Tables_integration/","page":"Tables.jl","title":"Tables.jl","text":"df_equity_history = DataFrame(equity_data)\n\nprintln(df_equity_history)","category":"page"},{"location":"integrations/gen/1_Tables_integration/#Convert-balance-collector-data-to-DataFrame","page":"Tables.jl","title":"Convert balance collector data to DataFrame","text":"","category":"section"},{"location":"integrations/gen/1_Tables_integration/","page":"Tables.jl","title":"Tables.jl","text":"df_drawdown_history = DataFrame(drawdown_data)\n\nprintln(df_drawdown_history)","category":"page"},{"location":"execution_errors/#Execution-and-errors","page":"Execution and errors","title":"Execution and errors","text":"","category":"section"},{"location":"execution_errors/","page":"Execution and errors","title":"Execution and errors","text":"Execution behavior (user-facing):","category":"page"},{"location":"execution_errors/","page":"Execution and errors","title":"Execution and errors","text":"fill_order! records a Trade when the fill is accepted.\nWhen a fill is rejected, fill_order! throws OrderRejectError.\nsettle_expiry!, process_expiries!, liquidate_all!, and liquidate_to_maintenance! send close-only synthetic fills (fill_qty = -position_qty) with allow_inactive=true, so they do not reject on incremental margin checks (inc_qty == 0).\nThose helpers can still throw non-rejection errors (for example stale/non-finite stored quote state or liquidation loop limits).","category":"page"},{"location":"execution_errors/","page":"Execution and errors","title":"Execution and errors","text":"using Fastback, Dates\n\nacc = Account(;\n    broker=FlatFeeBroker(pct=0.001),\n    base_currency=CashSpec(:USD),\n)\ndeposit!(acc, :USD, 100.0)\ninst = register_instrument!(acc, spot_instrument(:ABC, :ABC, :USD))\n\norder = Order(oid!(acc), inst, DateTime(2024, 1, 2), 200.0, 1.0)\n\ntry\n    fill_order!(acc, order; dt=order.date, fill_price=order.price, bid=order.price, ask=order.price, last=order.price)\ncatch err\n    err isa OrderRejectError ? string(\"rejected: \", err.reason) : rethrow()\nend","category":"page"},{"location":"glossary/#Glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"glossary/#Account","page":"Glossary","title":"Account","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Account is Fastback's central state object. It owns a CashLedger (acc.ledger) for cash assets, balances, equities, and margin vectors, plus open positions, executed trades, and order/trade sequence counters.","category":"page"},{"location":"glossary/#Order","page":"Glossary","title":"Order","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"An Order encapsulates an instruction to trade an instrument at a specific time, price, and quantity, with optional take_profit and stop_loss levels. Orders translate into trades through fill_order!.","category":"page"},{"location":"glossary/#Trade","page":"Glossary","title":"Trade","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A Trade records the actual execution of an order, including fill price, filled and remaining quantity, realized quantity, gross additive fill P&L in settlement currency (fill_pnl_settle), commission (commission_settle), settlement cash movement (cash_delta_settle), and the pre-trade position state. Trades accumulate in Account.trades.","category":"page"},{"location":"glossary/#Position","page":"Glossary","title":"Position","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A Position maintains the net exposure for an instrument using a weighted-average cost basis. It stores the average prices, quantity, and unrealized P&L caches (pnl_quote, pnl_settle). For principal-exchange instruments, pnl_settle includes both quote-price move and FX translation versus avg_entry_price_settle. Positions are stored in Account.positions.","category":"page"},{"location":"glossary/#Instrument","page":"Glossary","title":"Instrument","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Instrument models a tradable product, binding together the display symbol, base asset settings, and quote asset settings. Instruments must be registered with an account before use using the register_instrument! function. Contract type (contract_kind) and lifecycle bounds (start_time, expiry) let you represent spot pairs, perpetual swaps, and dated futures explicitly.","category":"page"},{"location":"glossary/#Spot-on-Margin","page":"Glossary","title":"Spot on Margin","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A principal-exchange spot instrument with an explicit margin requirement (percent-notional or fixed-per-contract) represents \"spot on margin\". Leveraged longs/shorts post margin, and shorts can accrue borrow fees via short_borrow_rate (borrow-fee clocks are tracked per position and aligned to fills). For PercentNotional, margin parameters are equity fractions of notional (IMR/MMR-style), not collateral-inclusive ratios. Short-sale proceeds treatment for interest accrual is broker-driven through broker_short_proceeds_rates (exclude fraction + optional rebate rate).","category":"page"},{"location":"glossary/#Base-Asset","page":"Glossary","title":"Base Asset","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The base asset represents the tradable quantity of an instrument (e.g. shares, contracts, coins). Instruments define their base symbol, tick size, min/max quantity, and display precision via base_symbol, base_tick, base_min, base_max, and base_digits.","category":"page"},{"location":"glossary/#Price","page":"Glossary","title":"Price","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Price is a type alias for Float64 used for quote-currency values—trade prices, commissions, P&L figures, and so on. Quote precision and tick sizes are instrument-defined.","category":"page"},{"location":"glossary/#Quantity","page":"Glossary","title":"Quantity","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Quantity is a type alias for Float64 describing position or order size. Positive quantities represent long exposure; negative quantities represent short exposure across orders, trades, and positions.","category":"page"},{"location":"glossary/#Exposure","page":"Glossary","title":"Exposure","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Exposure is the signed quantity of an open position. Helper predicates such as has_exposure, is_long, is_short, and trade_dir determine exposure state for Positions and Accounts.","category":"page"},{"location":"glossary/#Fill","page":"Glossary","title":"Fill","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A fill is the execution of an order (whole or partial). fill_order! creates a Trade with the fill price, fill quantity, remaining quantity, and realized P&L.","category":"page"},{"location":"glossary/#Commission","page":"Glossary","title":"Commission","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Commission is specified by the active broker profile and converted from quote to settlement currency on each fill, then stored on the trade as commission_settle. This amount is applied to balances, equities, and realized P&L in settlement units.","category":"page"},{"location":"glossary/#Realized-P-and-L","page":"Glossary","title":"Realized P&L","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"fill_pnl_settle is gross fill-settled P&L (commissions excluded).","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"For principal-exchange settlement, fill_pnl_settle equals closed-position realized P&L when exposure decreases (realized_qty). For variation-margin settlement, it includes both open mark-to-fill settlement and reduce-basis settlement, and fills reset avg_settle_price to the current mark.","category":"page"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Commissions are separate via commission_settle. The actual fill cash movement is always cash_delta_settle; for variation margin, cash_delta_settle = fill_pnl_settle - commission_settle.","category":"page"},{"location":"glossary/#Unrealized-P-and-L","page":"Glossary","title":"Unrealized P&L","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Unrealized P&L is cached on positions as pnl_quote and pnl_settle. update_marks! keeps these caches in sync and mirrors the resulting value change into equity. For principal-exchange cross-currency positions, pnl_settle includes principal FX translation from the settlement-entry basis.","category":"page"},{"location":"glossary/#Trade-Direction","page":"Glossary","title":"Trade Direction","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"TradeDir is the @enumx representing trade direction: Buy, Sell, or Null. Conversion helpers such as trade_dir(quantity), is_long, is_short, and opposite_dir provide directional logic across orders, trades, and positions.","category":"page"},{"location":"glossary/#Balance","page":"Glossary","title":"Balance","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A balance is the cash-only value associated with a Cash asset. Deposits, withdrawals, commissions, and realized P&L update balances; floating P&L from open positions does not. Access balances through cash_balance(acc, cash).","category":"page"},{"location":"glossary/#Equity","page":"Glossary","title":"Equity","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Equity is the balance of a cash asset plus the unrealized P&L of open positions denominated in that currency. Access equities through equity(acc, cash).","category":"page"},{"location":"glossary/#Cash-Asset","page":"Glossary","title":"Cash Asset","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A Cash object models a funding currency (USD, EUR, BTC, …) with display precision and a ledger-assigned index. Cash is owned by CashLedger. Register currencies through register_cash_asset!(acc, CashSpec(:EUR)) to get account-owned Cash handles.","category":"page"},{"location":"glossary/#Collector","page":"Glossary","title":"Collector","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Collectors are lightweight recorders that capture time-series or summary statistics during a backtest. periodic_collector, predicate_collector, drawdown_collector, and helpers like min_value_collector are part of the collectors API and return both the collecting closure and the mutable storage.","category":"page"},{"location":"glossary/#Exchange-Rate","page":"Glossary","title":"Exchange Rate","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"ExchangeRates converts values between cash assets using a mutable matrix of pairwise rates and implied reciprocals.","category":"page"},{"location":"glossary/#Batch-Backtest","page":"Glossary","title":"Batch Backtest","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"batch_backtest runs a vector of parameter sets across one backtest function, optionally multi-threaded, while reporting progress and optional callbacks.","category":"page"},{"location":"how_to/#How-to-recipes","page":"How-to","title":"How-to recipes","text":"","category":"section"},{"location":"how_to/","page":"How-to","title":"How-to","text":"Short, practical snippets for common workflows.","category":"page"},{"location":"how_to/#Drive-the-engine-with-process_step!","page":"How-to","title":"Drive the engine with process_step!","text":"","category":"section"},{"location":"how_to/","page":"How-to","title":"How-to","text":"using Fastback\nusing Dates\n\ner = ExchangeRates()\nacc = Account(;\n    broker=FlatFeeBroker(pct=0.001),\n    funding=AccountFunding.Margined,\n    base_currency=CashSpec(:USD),\n    exchange_rates=er,\n)\nusd = cash_asset(acc, :USD)\neur = register_cash_asset!(acc, CashSpec(:EUR))\ndeposit!(acc, usd, 10_000.0)\ndeposit!(acc, eur, 5_000.0)\n\ninst = register_instrument!(acc, perpetual_instrument(\n    :BTCUSD, :BTC, :USD;\n    margin_requirement=MarginRequirement.PercentNotional,\n    margin_init_long=0.10,\n    margin_init_short=0.10,\n    margin_maint_long=0.05,\n    margin_maint_short=0.05,\n))\n\ndt = DateTime(2024, 1, 1, 0)\nbid, ask, last = 100.0, 100.5, 100.2\nfunding_rate = 0.0001\neurusd = 1.07\n\nfx_updates = [FXUpdate(eur, usd, eurusd)]\nmarks = [MarkUpdate(inst.index, bid, ask, last)]\nfunding = [FundingUpdate(inst.index, funding_rate)]\n\nprocess_step!(acc, dt; fx_updates=fx_updates, marks=marks, funding=funding, expiries=true, liquidate=false)","category":"page"},{"location":"how_to/","page":"How-to","title":"How-to","text":"Notes:","category":"page"},{"location":"how_to/","page":"How-to","title":"How-to","text":"process_step! enforces non-decreasing timestamps and accrues interest/borrow fees before same-step FX/mark updates.\nFX updates are applied on the account's ExchangeRates.\nCash registration is account-owned: use register_cash_asset!(acc, CashSpec(:EUR)) and ExchangeRates is resized automatically.\nSetup order: create Account, register additional cash assets, set FX rates, then fund it.\nOrders are filled separately with fill_order!.\nFor MarginRequirement.PercentNotional, margin_init_* / margin_maint_* are equity fractions of notional (0.10 means 10%).","category":"page"},{"location":"how_to/#Manual-event-loop","page":"How-to","title":"Manual event loop","text":"","category":"section"},{"location":"how_to/","page":"How-to","title":"How-to","text":"Use this when you need custom ordering or extra side effects per step.","category":"page"},{"location":"how_to/","page":"How-to","title":"How-to","text":"# advance time (accrues interest/borrow fees by default)\nadvance_time!(acc, dt)\n\n# optional FX update\nupdate_rate!(er, eur, usd, 1.07)\n\n# mark positions (also revalues equity for open positions)\nupdate_marks!(acc, inst, dt, bid, ask, last)\n\n# funding and expiries (if applicable)\napply_funding!(acc, inst, dt; funding_rate=funding_rate)\nprocess_expiries!(acc, dt)\n\n# optional liquidation pass\nis_under_maintenance(acc) && liquidate_to_maintenance!(acc, dt)","category":"page"},{"location":"how_to/#Multi-currency-equity-in-base-currency","page":"How-to","title":"Multi-currency equity in base currency","text":"","category":"section"},{"location":"how_to/","page":"How-to","title":"How-to","text":"er = ExchangeRates()\nacc = Account(;\n    broker=FlatFeeBroker(pct=0.001),\n    funding=AccountFunding.Margined,\n    base_currency=CashSpec(:USD),\n    exchange_rates=er,\n)\nusd = cash_asset(acc, :USD)\neur = register_cash_asset!(acc, CashSpec(:EUR))\ndeposit!(acc, usd, 10_000.0)\ndeposit!(acc, eur, 5_000.0)\n\nupdate_rate!(er, eur, usd, 1.07)\nequity_base_ccy(acc) # total equity in USD","category":"page"},{"location":"how_to/#Use-Tables.jl-outputs","page":"How-to","title":"Use Tables.jl outputs","text":"","category":"section"},{"location":"how_to/","page":"How-to","title":"How-to","text":"using DataFrames\n\ndf_trades = DataFrame(trades_table(acc))\ndf_positions = DataFrame(positions_table(acc))\ndf_balances = DataFrame(balances_table(acc))\ndf_equities = DataFrame(equities_table(acc))\ndf_cashflows = DataFrame(cashflows_table(acc))","category":"page"},{"location":"how_to/","page":"How-to","title":"How-to","text":"Notes:","category":"page"},{"location":"how_to/","page":"How-to","title":"How-to","text":"df_trades.fill_pnl_settle is the additive gross fill-settled P&L column.\ndf_trades.cash_delta_settle is the additive net cash movement per fill.","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"Portfolio trading","title":"Portfolio trading","text":"EditURL = \"../2_portfolio_trading.jl\"","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"Portfolio trading","title":"Portfolio trading","text":"Jupyter Notebook: 2_portfolio_trading.ipynb","category":"page"},{"location":"examples/gen/2_portfolio_trading/#Portfolio-trading-strategy-example","page":"Portfolio trading","title":"Portfolio trading strategy example","text":"","category":"section"},{"location":"examples/gen/2_portfolio_trading/","page":"Portfolio trading","title":"Portfolio trading","text":"This example demonstrates how to run a backtest with multiple assets, i.e. trading a portfolio of assets.","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"Portfolio trading","title":"Portfolio trading","text":"The price data is loaded from a CSV file containing daily close prices for the stocks AAPL, NVDA, TSLA, and GE, ranging from 2022-01-03 to 2024-04-22.","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"Portfolio trading","title":"Portfolio trading","text":"The strategy buys one stock if the last 4 days were positive, and sells it again if the last 2 days were negative. Each trade is executed at a commission of 0.1%.","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"Portfolio trading","title":"Portfolio trading","text":"When missing data points are detected for a stock, all open positions for that stock are closed. Logic of this type is common in real-world strategies and harder to implement in a vectorized way, showcasing the flexibility of Fastback.","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"Portfolio trading","title":"Portfolio trading","text":"The account equity, balance and drawdowns are collected for every day and plotted at the end using the Plots package. Additionally, the performance and P&L breakdown of each stock is plotted and statistics (avg. P&L, worst P&L, best P&L, win rate) are printed.","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"Portfolio trading","title":"Portfolio trading","text":"using Fastback\nusing Dates\nusing CSV\nusing DataFrames\n\ndata_path = \"../data/stocks_1d.csv\";\n\n# if data path doesn't exist, try to change working directory\nisfile(data_path) || cd(\"src/examples\")\n\n# load CSV daily stock data for symbols AAPL, NVDA, TSLA, GE\ndf_csv = DataFrame(CSV.File(data_path; dateformat=\"yyyy-mm-dd HH:MM:SS\"));\ndf_csv.symbol = Symbol.(df_csv.symbol); # convert string to symbol type\ndf = unstack(df_csv, :dt_close, :symbol, :close) # pivot long to wide format\nsymbols = Symbol.(names(df)[2:end]);\n\n# print summary\ndescribe(df)\n\n# create trading account with $10'000 start capital\nacc = Account(;\n    funding=AccountFunding.Margined,\n    base_currency=CashSpec(:USD),\n    broker=FlatFeeBroker(; pct=0.001),\n);\nusd = cash_asset(acc, :USD)\ndeposit!(acc, :USD, 10_000.0);\n\n# register instruments for all symbols\ninstruments = map(sym -> spot_instrument(sym, sym, :USD), symbols);\nregister_instrument!.(Ref(acc), instruments);\n\n# data collectors (sampling every day)\ncollect_balance, balance_data = periodic_collector(Float64, Day(1));\ncollect_equity, equity_data = periodic_collector(Float64, Day(1));\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Day(1));\ncollect_portfolio_weights, portfolio_weights_data = portfolio_weights_collector(acc, instruments, Day(1); cash=usd);\n\nfunction open_position!(acc, inst, dt, price)\n    # invest 20% of equity in the position\n    qty = 0.2equity(acc, usd) / price\n    order = Order(oid!(acc), inst, dt, price, qty)\n    fill_order!(acc, order; dt=dt, fill_price=price, bid=price, ask=price, last=price)\nend\n\nfunction close_position!(acc, inst, dt, price)\n    # close position for instrument, if any\n    pos = get_position(acc, inst)\n    has_exposure(pos) || return\n    order = Order(oid!(acc), inst, dt, price, -pos.quantity)\n    fill_order!(acc, order; dt=dt, fill_price=price, bid=price, ask=price, last=price)\nend\n\n# loop over each row of DataFrame\nfor i in 6:nrow(df)\n    row = df[i, :]\n    dt = row.dt_close\n\n    # loop over all instruments and check strategy rules\n    for inst in instruments\n        price = row[inst.symbol]\n\n        window_open = @view df[i-4:i, inst.symbol]\n        window_close = @view df[i-2:i, inst.symbol]\n\n        # close position of instrument if missing data\n        if any(ismissing.(window_open))\n            close_price = get_position(acc, inst).avg_entry_price\n            close_position!(acc, inst, dt, close_price)\n            continue\n        end\n\n        if !is_exposed_to(acc, inst)\n            # buy if last 4 days were positive\n            all(diff(window_open) .> 0) && open_position!(acc, inst, dt, price)\n        else\n            # close position if last 2 days were negative\n            all(diff(window_close) .< 0) && close_position!(acc, inst, dt, price)\n        end\n\n        # update position and account P&L\n        update_marks!(acc, inst, dt, price, price, price)\n    end\n\n    # close all positions at the end of backtest\n    if i == nrow(df)\n        for inst in instruments\n            price = row[inst.symbol]\n            close_position!(acc, inst, dt, price)\n        end\n    end\n\n    # collect data for plotting\n    if should_collect(equity_data, dt)\n        equity_value = equity(acc, usd)\n        collect_balance(dt, cash_balance(acc, usd))\n        collect_equity(dt, equity_value)\n        collect_drawdown(dt, equity_value)\n    end\n\n    should_collect(portfolio_weights_data, dt) && collect_portfolio_weights(dt)\nend\n\n# print account summary\nshow(acc)","category":"page"},{"location":"examples/gen/2_portfolio_trading/#Plot-account-balance,-equity,-drawdowns-and-stocks-performance","page":"Portfolio trading","title":"Plot account balance, equity, drawdowns and stocks performance","text":"","category":"section"},{"location":"examples/gen/2_portfolio_trading/","page":"Portfolio trading","title":"Portfolio trading","text":"using Plots, Query, Printf, Measures\n\ntheme(:juno)\n\n# equity / cash balance\np1 = plot()\nFastback.plot_balance!(p1, balance_data; title=\"Account\")\nFastback.plot_equity!(p1, equity_data)\n\n# drawdowns\np2 = Fastback.plot_drawdown(drawdown_data)\n\n# stocks performance\np3 = plot(\n    df.dt_close, df[!, 2] ./ df[1, 2];\n    title=\"Stocks performance (normalized)\",\n    yformatter=y -> @sprintf(\"%.1f\", y),\n    label=names(df)[2],\n    linetype=:steppost,\n    color=:green,\n);\nfor i in 3:ncol(df)\n    plot!(p3,\n        df.dt_close, df[!, i] ./ df[1, i];\n        label=names(df)[i])\nend\n\n# portfolio constituent weights\np4 = Fastback.plot_portfolio_weights_over_time(portfolio_weights_data)\n\n# P&L breakdown by stocks\npnl_by_inst = acc.trades |>\n              @groupby(_.order.inst.symbol) |>\n              @map({\n                  symbol = key(_),\n                  pnl = sum(getfield.(_, :fill_pnl_settle))\n              }) |> DataFrame\np5 = bar(string.(pnl_by_inst.symbol), pnl_by_inst.pnl;\n    legend=false,\n    title=\"P&L breakdown by stocks [USD]\",\n    permute=(:x, :y),\n    xlims=(0, size(pnl_by_inst)[1]),\n    yformatter=y -> @sprintf(\"%.0f\", y),\n    color=\"#BBBB00\",\n    linecolor=nothing,\n    bar_width=0.5)\n\nplot(p1, p2, p3, p4, p5;\n    layout=@layout[a{0.3h}; b{0.12h}; c{0.22h}; d{0.2h}; e{0.16h}],\n    size=(850, 920), margin=0mm, left_margin=5mm)","category":"page"},{"location":"examples/gen/2_portfolio_trading/#Calculate-statistics-per-stock","page":"Portfolio trading","title":"Calculate statistics per stock","text":"","category":"section"},{"location":"examples/gen/2_portfolio_trading/","page":"Portfolio trading","title":"Portfolio trading","text":"Calculates summary statistics for each stock. Using the Query.jl package, all trades are first grouped by instrument symbol, then average P&L, worst P&L, best P&L, and win rate are calculated. Finally, the results are piped into a DataFrame and printed using the PrettyTables.jl package.","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"Portfolio trading","title":"Portfolio trading","text":"using PrettyTables\n\ndf = acc.trades |>\n@groupby(_.order.inst.symbol) |>\n@map({\n    symbol = key(_),\n    avg_pnl = sum(getfield.(_, :fill_pnl_settle)) / length(_),\n    worst_pnl = minimum(getfield.(_, :fill_pnl_settle)),\n    best_pnl = maximum(getfield.(_, :fill_pnl_settle)),\n    win_rate = round.(count(getfield.(_, :fill_pnl_settle) .> 0) / count(is_realizing.(_)), sigdigits=2),\n}) |> DataFrame\n\npretty_table(df; column_labels=[\"Symbol\", \"Avg P&L\", \"Worst P&L\", \"Best P&L\", \"Win Rate\"])","category":"page"},{"location":"api_index/#API-index","page":"API index","title":"API index","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"Exhaustive public API list (core + Plots extension). For narrative guidance, see How-to and Glossary. For details, open the REPL and type ?symbol to view docstrings.","category":"page"},{"location":"api_index/#Core-types-and-enums","page":"API index","title":"Core types and enums","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"Price, Quantity\nTradeDir, SettlementStyle, MarginRequirement, MarginAggregation, ContractKind, AccountFunding, CashflowKind, OrderRejectReason, OrderRejectError, TradeReason\nCash, CashSpec, Instrument, Order, Trade, Cashflow, Position, Account\nExchangeRates","category":"page"},{"location":"api_index/#Trade-direction-helpers","page":"API index","title":"Trade direction helpers","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"trade_dir, is_long, is_short, opposite_dir","category":"page"},{"location":"api_index/#Broker-hooks","page":"API index","title":"Broker hooks","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"broker_commission, broker_interest_rates, broker_short_proceeds_rates","category":"page"},{"location":"api_index/#Order-and-trade-utilities","page":"API index","title":"Order and trade utilities","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"symbol, notional_value, fill_order!\nrealized_notional_quote, is_realizing, realized_return_gross, realized_return_net","category":"page"},{"location":"api_index/#Cash-ledger-operations","page":"API index","title":"Cash ledger operations","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"cash_asset, cash_index, has_cash_asset, register_cash_asset!","category":"page"},{"location":"api_index/#Account-operations","page":"API index","title":"Account operations","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"quote_cash, settle_cash, margin_cash\nget_rate_base_ccy, to_settle, to_quote, to_margin, to_base\ncash_balance, equity, equity_base_ccy, balance_base_ccy\ninit_margin_used, init_margin_used_base_ccy, maint_margin_used, maint_margin_used_base_ccy\navailable_funds, available_funds_base_ccy, excess_liquidity, excess_liquidity_base_ccy\nmaint_deficit_base_ccy, init_deficit_base_ccy, is_under_maintenance\ndeposit!, withdraw!, accrue_interest!, accrue_borrow_fees!, apply_funding!\nregister_instrument!, get_position, is_exposed_to, oid!, format_datetime\nliquidate_all!, liquidate_to_maintenance!","category":"page"},{"location":"api_index/#Position-analytics","page":"API index","title":"Position analytics","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"has_exposure, value_quote, pnl_quote","category":"page"},{"location":"api_index/#Contract-math","page":"API index","title":"Contract math","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"calc_value_quote, calc_pnl_quote\nmargin_init_margin_ccy, margin_maint_margin_ccy","category":"page"},{"location":"api_index/#Exchange-rate-utilities","page":"API index","title":"Exchange rate utilities","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"get_rate, get_rates_matrix, update_rate!","category":"page"},{"location":"api_index/#Portfolio-logic","page":"API index","title":"Portfolio logic","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"update_marks!, settle_expiry!","category":"page"},{"location":"api_index/#Collectors","page":"API index","title":"Collectors","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"PeriodicValues, PredicateValues, DrawdownValues, PortfolioWeightsValues, DrawdownMode, dates\nperiodic_collector, predicate_collector, drawdown_collector, portfolio_weights_collector, should_collect\nMinValue, MaxValue, min_value_collector, max_value_collector","category":"page"},{"location":"api_index/#Event-driver","page":"API index","title":"Event driver","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"MarkUpdate, FundingUpdate, FXUpdate\nadvance_time!, process_step!, process_expiries!","category":"page"},{"location":"api_index/#Backtesting","page":"API index","title":"Backtesting","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"batch_backtest","category":"page"},{"location":"api_index/#Tables-integration","page":"API index","title":"Tables integration","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"balances_table, equities_table, positions_table, trades_table, cashflows_table","category":"page"},{"location":"api_index/#Analytics","page":"API index","title":"Analytics","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"performance_summary_table","category":"page"},{"location":"api_index/#Formatting-helpers","page":"API index","title":"Formatting helpers","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"format_cash, format_base, format_quote\ncalc_base_qty_for_notional\nhas_expiry, is_expired, is_active, ensure_active\nspot_instrument, perpetual_instrument, future_instrument","category":"page"},{"location":"api_index/#Printing-helpers","page":"API index","title":"Printing helpers","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"print_cash_balances, print_equity_balances, print_positions, print_trades, print_cashflows","category":"page"},{"location":"api_index/#Utilities","page":"API index","title":"Utilities","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"params_combinations","category":"page"},{"location":"api_index/#Plots-extension-(requires-Plots.jl;-violins-need-StatsPlots)","page":"API index","title":"Plots extension (requires Plots.jl; violins need StatsPlots)","text":"","category":"section"},{"location":"api_index/","page":"API index","title":"API index","text":"plot_title\nplot_balance, plot_balance!\nplot_equity, plot_equity!\nplot_open_orders_count, plot_open_orders_count!\nplot_drawdown, plot_drawdown!\nplot_equity_drawdown, plot_equity_drawdown!\nplot_exposure, plot_exposure!\nplot_portfolio_weights_over_time\nplot_violin_realized_returns_by_day, plot_violin_realized_returns_by_hour\nplot_realized_cum_returns_by_hour\nplot_realized_cum_returns_by_weekday","category":"page"},{"location":"getting_started/#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"This page gets you to a running backtest in a few minutes.","category":"page"},{"location":"getting_started/#Install","page":"Getting started","title":"Install","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using Pkg\nPkg.add(\"Fastback\")","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Optional plotting extras:","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using Pkg\nPkg.add([\"Plots\", \"StatsPlots\"])","category":"page"},{"location":"getting_started/#Hello-world-backtest","page":"Getting started","title":"Hello world backtest","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"The example below runs a tiny event-driven loop, marks positions each step, and opens and closes a single position.","category":"page"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"using Fastback\nusing Dates\n\n# 1) Account and cash\nacc = Account(;\n    funding=AccountFunding.FullyFunded,\n    base_currency=CashSpec(:USD),\n    broker=FlatFeeBroker(pct=0.001),\n)\nusd = cash_asset(acc, :USD)\ndeposit!(acc, usd, 10_000.0)\n\n# 2) Instrument (spot, principal-exchange principal exchange)\nABC = register_instrument!(acc, spot_instrument(:ABC, :ABC, :USD))\n\n# 3) Small price series\ndts = [DateTime(2024, 1, 1) + Hour(i) for i in 0:5]\nprices = [100.0, 101.0, 99.5, 102.0, 101.0, 103.0]\n\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1))\n\nfor (dt, price) in zip(dts, prices)\n    # Mark to market at each step (bid/ask/last are equal here for simplicity).\n    update_marks!(acc, ABC, dt, price, price, price)\n\n    if dt == dts[2] # open\n        order = Order(oid!(acc), ABC, dt, price, 10.0)\n        fill_order!(acc, order; dt=dt, fill_price=price, bid=price, ask=price, last=price)\n    elseif dt == dts[5] # close\n        pos = get_position(acc, ABC)\n        order = Order(oid!(acc), ABC, dt, price, -pos.quantity)\n        fill_order!(acc, order; dt=dt, fill_price=price, bid=price, ask=price, last=price)\n    end\n\n    if should_collect(equity_data, dt)\n        collect_equity(dt, equity(acc, usd))\n    end\nend\n\nequity(acc, usd)\n\n# optional plot (requires Plots.jl)\nusing Plots\nFastback.plot_equity(equity_data)","category":"page"},{"location":"getting_started/#Next-steps","page":"Getting started","title":"Next steps","text":"","category":"section"},{"location":"getting_started/","page":"Getting started","title":"Getting started","text":"Read Basic setup for a checklist of the typical backtest components.\nRead Accounting model and event loop to understand balances, equity, margin, and marks.\nBrowse the Examples for end-to-end strategies and integrations.","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"EditURL = \"../5_VOO_vs_MES_comparison/main.jl\"","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"Jupyter Notebook: 5_VOO_vs_MES_comparison.ipynb","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/#S-and-P-500-exposure:-VOO-on-Reg-T-margin-vs-Micro-E-mini-futures-(MES)","page":"VOO vs MES cost comparison","title":"S&P 500 exposure: VOO on Reg-T margin vs Micro E-mini futures (MES)","text":"","category":"section"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"This example compares two ways to express S&P 500 exposure:","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"VOO ETF on Reg-T margin (principal-exchange spot)\nMicro E-mini S&P 500 futures (MES) on variation margin","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"It runs the same random trade schedule under two leverage factors (1.0x and 2.0x) so we can see how leverage changes costs and outcomes for each vehicle.","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"Data window: 2020-01 to 2024-12.","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"Modeling assumptions:","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"VOO uses OHLCV plus dividend/split files and is transformed to a simple total-return-like series (dividends embedded into price path).\nMES marks use the daily front contract (highest volume) from the MES contract panel, with explicit rolls from data/MES_roll_dates.csv.\nCommissions and financing are generated by IBKRProFixedBroker.\nUSD financing rates use data/IBKR_USD_benchmark.csv as a compact placeholder schedule for this tutorial.","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"using Fastback\nusing Dates\nusing CSV\nusing DataFrames\nusing Random","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"example_dir = normpath(joinpath(@__DIR__, \"..\", \"..\", \"..\", \"src\", \"examples\", \"5_VOO_vs_MES_comparison\"))\nisdir(example_dir) || (example_dir = @__DIR__)\ndata_dir = joinpath(example_dir, \"data\")\n\ninclude(joinpath(example_dir, \"data.jl\"))\n\n# load daily data and align to shared calendar\nconst BACKTEST_START = Date(2020, 1, 1)\nconst BACKTEST_END = Date(2024, 12, 31)\nvoo_df = load_voo_df(\n    data_dir;\n    start_dt=BACKTEST_START,\n    end_dt=BACKTEST_END,\n    half_spread=0.01,\n)\nmes_front_df = load_mes_front_data_df(\n    data_dir;\n    start_dt=BACKTEST_START,\n    end_dt=BACKTEST_END,\n    half_spread=0.125,\n)\nvoo_df, mes_front_df = align_on_common_dates(voo_df, mes_front_df)\n\n# MES rolling and fee setup from explicit roll schedule\nmes_contract_specs = load_mes_contract_specs(\n    data_dir;\n    start_dt=first(mes_front_df.dt),\n    end_dt=last(mes_front_df.dt),\n)\nmes_per_contract_fees = Dict(\n    spec.symbol => 1.22  # 0.85 + 0.35 + 0.02\n    for spec in mes_contract_specs\n)\n\n# load USD benchmark schedule\nconst IBKR_USD_BENCHMARK = load_usd_benchmark_schedule(data_dir);\nnothing #hide","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"function make_ibkr_profile(usd_benchmark_schedule; credit_no_interest_balance, futures_per_contract)\n    IBKRProFixedBroker(\n        time_type=Date,\n        equity_per_share=0.005,\n        equity_min=1.00,\n        equity_max_pct=0.01,\n        futures_per_contract=futures_per_contract,\n        benchmark_by_cash=Dict(:USD => usd_benchmark_schedule),\n        borrow_spread=0.015,\n        lend_spread=0.005,\n        credit_no_interest_balance=credit_no_interest_balance,\n    )\nend\n\nvoo_broker = make_ibkr_profile(\n    IBKR_USD_BENCHMARK;\n    credit_no_interest_balance=10_000,\n    futures_per_contract=Dict{Symbol,Price}(),\n)\n\nmes_broker = make_ibkr_profile(\n    IBKR_USD_BENCHMARK;\n    credit_no_interest_balance=10_000,\n    futures_per_contract=mes_per_contract_fees,\n);\nnothing #hide","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"# shared backtest loop\nfunction run_backtest!(\n    acc,\n    inst,\n    df,\n    trade_lookup;\n    target_notional,\n)\n    for (i, row) in enumerate(eachrow(df))\n        dt = row.dt\n        bid, ask = row.bid, row.ask\n        last = row.last\n\n        marks = [MarkUpdate(inst.index, bid, ask, last)]\n        process_step!(acc, dt; marks=marks, liquidate=true)\n\n        event_no = get(trade_lookup, i, 0)\n        if event_no != 0\n            target_qty = isodd(event_no) ? calc_base_qty_for_notional(inst, last, target_notional) : 0.0\n            pos = get_position(acc, inst)\n            delta_qty = target_qty - pos.quantity\n\n            if delta_qty != 0.0\n                fill_px = delta_qty > 0 ? ask : bid\n                order = Order(oid!(acc), inst, dt, fill_px, delta_qty)\n                fill_order!(acc, order, dt=dt, fill_price=fill_px, bid=bid, ask=ask, last=last)\n            end\n        end\n    end\n\n    # close any remaining position at the end\n    pos = get_position(acc, inst)\n    if has_exposure(pos)\n        row = df[end, :]\n        fill_px = pos.quantity > 0 ? row.bid : row.ask\n        order = Order(oid!(acc), inst, row.dt, fill_px, -pos.quantity)\n        fill_order!(acc, order, dt=row.dt, fill_price=fill_px, bid=row.bid, ask=row.ask, last=row.last)\n    end\n\n    acc\nend\n\n# MES futures backtest with explicit rolls\nfunction run_mes_chain_backtest!(\n    acc,\n    mes_chain,\n    mes_roll_dates,\n    df,\n    trade_lookup;\n    target_notional,\n)\n    active_idx = 1\n\n    for (i, row) in enumerate(eachrow(df))\n        dt = row.dt\n        bid, ask = row.bid, row.ask\n        last = row.last\n\n        active_inst = mes_chain[active_idx]\n        process_step!(acc, dt; marks=[MarkUpdate(active_inst.index, bid, ask, last)], liquidate=true)\n\n        while active_idx < length(mes_chain)\n            roll_dt = mes_roll_dates[active_idx]\n            dt < roll_dt && break\n\n            next_inst = mes_chain[active_idx+1]\n            pos = get_position(acc, active_inst)\n            if has_exposure(pos)\n                close_px = pos.quantity > 0 ? bid : ask\n                open_px = pos.quantity > 0 ? ask : bid\n                roll_position!(\n                    acc,\n                    active_inst,\n                    next_inst,\n                    dt;\n                    close_fill_price=close_px,\n                    close_bid=bid,\n                    close_ask=ask,\n                    close_last=last,\n                    open_fill_price=open_px,\n                    open_bid=bid,\n                    open_ask=ask,\n                    open_last=last,\n                )\n            end\n\n            active_idx += 1\n            active_inst = mes_chain[active_idx]\n        end\n\n        event_no = get(trade_lookup, i, 0)\n        if event_no != 0\n            target_qty = isodd(event_no) ? calc_base_qty_for_notional(active_inst, last, target_notional) : 0.0\n            pos = get_position(acc, active_inst)\n            delta_qty = target_qty - pos.quantity\n\n            if delta_qty != 0.0\n                fill_price = delta_qty > 0 ? ask : bid\n                order = Order(oid!(acc), active_inst, dt, fill_price, delta_qty)\n                fill_order!(acc, order; dt=dt, fill_price=fill_price, bid=bid, ask=ask, last=last)\n            end\n        end\n    end\n\n    # close any remaining positions at the end\n    for inst in mes_chain\n        pos = get_position(acc, inst)\n        if has_exposure(pos)\n            row = df[end, :]\n            fill_price = pos.quantity > 0 ? row.bid : row.ask\n            order = Order(oid!(acc), inst, row.dt, fill_price, -pos.quantity)\n            fill_order!(acc, order;\n                dt=row.dt,\n                fill_price=fill_price,\n                bid=row.bid,\n                ask=row.ask,\n                last=row.last,\n                allow_inactive=true,\n            )\n        end\n    end\n\n    acc\nend\n\n# helper: deterministic random trade schedule (~20 toggles in/out)\nfunction make_trade_lookup(n_rows; n_events=20, seed=2020)\n    rng = MersenneTwister(seed)\n    pool = collect(15:(n_rows-15))\n    trade_indices = sort(pool[randperm(rng, length(pool))[1:n_events]])\n    Dict(idx => i for (i, idx) in enumerate(trade_indices))\nend\n\n# account + instrument builders\n\nfunction build_voo_account(initial_cash, broker)\n    acc = Account(;\n        funding=AccountFunding.Margined,\n        base_currency=CashSpec(:USD),\n        time_type=Date,\n        broker=broker,\n    )\n    deposit!(acc, :USD, initial_cash)\n\n    voo = register_instrument!(\n        acc,\n        spot_instrument(\n            :VOO,\n            :VOO,\n            :USD;\n            time_type=Date,\n            base_tick=1.0,\n            base_digits=0,\n            quote_tick=0.01,\n            quote_digits=2,\n            margin_requirement=MarginRequirement.PercentNotional,\n            margin_init_long=0.50,\n            margin_init_short=0.35,  # equals 135% collateral-style notion\n            margin_maint_long=0.25,\n            margin_maint_short=0.20,  # equals 120% collateral-style notion\n        ),\n    )\n\n    acc, voo\nend\n\nfunction build_mes_account(initial_cash, broker, mes_specs)\n    acc = Account(\n        funding=AccountFunding.Margined,\n        base_currency=CashSpec(:USD),\n        time_type=Date,\n        broker=broker,\n    )\n    deposit!(acc, :USD, initial_cash)\n\n    mes_chain = Instrument{Date}[]\n    mes_roll_dates = Date[]\n    for spec in mes_specs\n        inst = register_instrument!(\n            acc,\n            future_instrument(\n                spec.symbol,\n                :MES,\n                :USD;\n                time_type=Date,\n                base_tick=1.0,\n                base_digits=0,\n                quote_tick=0.25,\n                quote_digits=2,\n                multiplier=5.0,\n                margin_requirement=MarginRequirement.FixedPerContract,\n                margin_init_long=2_800.0,\n                margin_init_short=2_800.0,\n                margin_maint_long=2_421.0,\n                margin_maint_short=2_421.0,\n                expiry=spec.expiry,\n            ),\n        )\n        push!(mes_chain, inst)\n        push!(mes_roll_dates, spec.roll_date)\n    end\n\n    acc, mes_chain, mes_roll_dates\nend\n\n# summarize results (costs + net equity)\n\nfunction summarize(acc, label, initial_cash, leverage_factor)\n    end_equity = equity(acc, cash_asset(acc, :USD))\n    pnl = end_equity - initial_cash\n    commissions = sum(t.commission_settle for t in acc.trades, init = 0.0)\n    roll_trades = count(t -> t.reason == TradeReason.Roll, acc.trades)\n    lend_interest = sum(cf.amount for cf in acc.cashflows if cf.kind == CashflowKind.LendInterest, init=0.0)\n    borrow_interest = -sum(cf.amount for cf in acc.cashflows if cf.kind == CashflowKind.BorrowInterest, init=0.0)\n    net_interest = lend_interest - borrow_interest\n    borrow_fees = sum(cf.amount for cf in acc.cashflows if cf.kind == CashflowKind.BorrowFee, init=0.0)\n\n    (\n        leverage=leverage_factor,\n        instrument=label,\n        target_notional=round(leverage_factor * initial_cash, digits=2),\n        trades=length(acc.trades),\n        roll_trades=roll_trades,\n        end_equity=round(end_equity, digits=2),\n        pnl=round(pnl, digits=2),\n        commissions=round(commissions, digits=2),\n        lend_interest=round(lend_interest, digits=2),\n        borrow_interest=round(borrow_interest, digits=2),\n        net_interest=round(net_interest, digits=2),\n        borrow_fees=round(borrow_fees, digits=2),\n    )\nend","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"# run scenarios\n\ninitial_cash = 200_000.0\nleverage_factors = (1.0, 2.0)\ntrade_lookup = make_trade_lookup(nrow(voo_df); n_events=20, seed=2020)\n\nrows = []\nfor leverage_factor in leverage_factors\n    target_notional = leverage_factor * initial_cash\n\n    acc_voo, voo = build_voo_account(initial_cash, voo_broker)\n    run_backtest!(acc_voo, voo, voo_df, trade_lookup; target_notional=target_notional)\n    push!(rows, summarize(acc_voo, \"VOO (Reg-T margin)\", initial_cash, leverage_factor))\n\n    acc_es, mes_chain, mes_roll_dates = build_mes_account(initial_cash, mes_broker, mes_contract_specs)\n    run_mes_chain_backtest!(\n        acc_es,\n        mes_chain,\n        mes_roll_dates,\n        mes_front_df,\n        trade_lookup;\n        target_notional=target_notional,\n    )\n    push!(rows, summarize(acc_es, \"MES (futures margin)\", initial_cash, leverage_factor))\nend\n\nsummary = DataFrame(rows)\nsort!(summary, [:leverage, :instrument])\nsummary","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"","category":"page"},{"location":"examples/gen/5_VOO_vs_MES_comparison/","page":"VOO vs MES cost comparison","title":"VOO vs MES cost comparison","text":"# compact view: leverage effect within each instrument\nleverage_effect_wide = combine(groupby(summary, :instrument)) do sdf\n    s1 = sdf[sdf.leverage.==1.0, :]\n    s2 = sdf[sdf.leverage.==2.0, :]\n    @assert nrow(s1) == 1 && nrow(s2) == 1\n\n    (\n        pnl_1x=s1.pnl[1],\n        pnl_2x=s2.pnl[1],\n        pnl_delta_2x_minus_1x=round(s2.pnl[1] - s1.pnl[1], digits=2),\n        roll_trades_1x=s1.roll_trades[1],\n        roll_trades_2x=s2.roll_trades[1],\n        comm_1x=s1.commissions[1],\n        comm_2x=s2.commissions[1],\n        lend_interest_1x=s1.lend_interest[1],\n        lend_interest_2x=s2.lend_interest[1],\n        borrow_interest_1x=s1.borrow_interest[1],\n        borrow_interest_2x=s2.borrow_interest[1],\n        net_interest_1x=s1.net_interest[1],\n        net_interest_2x=s2.net_interest[1],\n    )\nend\n\nmetric_cols = names(leverage_effect_wide, Not(:instrument))\nleverage_effect = DataFrame(metric=String.(metric_cols))\nfor row in eachrow(leverage_effect_wide)\n    leverage_effect[!, Symbol(row.instrument)] = [row[col] for col in metric_cols]\nend\n\nleverage_effect","category":"page"},{"location":"integrations/#Integrations","page":"Overview","title":"Integrations","text":"","category":"section"},{"location":"integrations/#Tables.jl","page":"Overview","title":"Tables.jl","text":"","category":"section"},{"location":"integrations/","page":"Overview","title":"Overview","text":"Fastback ships with zero-copy views that make every major account artefact available through the Tables.jl interface. That means you can hand results straight to DataFrames.jl, CSV.jl, Arrow.jl, or any other package that consumes Tables-compatible sources.","category":"page"},{"location":"integrations/","page":"Overview","title":"Overview","text":"Example: Tables integration walkthrough.","category":"page"},{"location":"integrations/#Account","page":"Overview","title":"Account","text":"","category":"section"},{"location":"integrations/","page":"Overview","title":"Overview","text":"accessor description\ntrades_table(acc) All executed trades with order and execution fields\npositions_table(acc) Current positions\nbalances_table(acc) Cash balances per currency\nequities_table(acc) Equity values per currency","category":"page"},{"location":"integrations/","page":"Overview","title":"Overview","text":"using DataFrames\nusing Fastback\n\ndf_trades = DataFrame(trades_table(acc))\ndf_positions = DataFrame(positions_table(acc))\ndf_balances = DataFrame(balances_table(acc))\ndf_equities = DataFrame(equities_table(acc))","category":"page"},{"location":"integrations/","page":"Overview","title":"Overview","text":"All helpers return read-through views, so changes to the underlying account are visible immediately without copying.","category":"page"},{"location":"integrations/","page":"Overview","title":"Overview","text":"Trade table semantics:","category":"page"},{"location":"integrations/","page":"Overview","title":"Overview","text":"fill_pnl_settle is additive gross fill-settled P&L.\ncash_delta_settle is additive net fill cash movement.","category":"page"},{"location":"integrations/#Collectors","page":"Overview","title":"Collectors","text":"","category":"section"},{"location":"integrations/","page":"Overview","title":"Overview","text":"Time-series collectors already satisfy the Tables.jl contract, so you can hand them directly to downstream packages. Drawdown collectors behave the same way, preserving the configured mode in each row.","category":"page"},{"location":"integrations/","page":"Overview","title":"Overview","text":"using Dates\nusing DataFrames\nusing Fastback\n\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1))\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(1))\n\n# ... run backtest and collect values ...\n\ndf_equity_history = DataFrame(equity_data)\ndf_drawdown_history = DataFrame(drawdown_data)","category":"page"},{"location":"integrations/#RiskPerf.jl","page":"Overview","title":"RiskPerf.jl","text":"","category":"section"},{"location":"integrations/","page":"Overview","title":"Overview","text":"Fastback integrates with RiskPerf.jl to generate summary performance tables as a single-row DataFrame.","category":"page"},{"location":"integrations/","page":"Overview","title":"Overview","text":"using DataFrames\nusing Fastback\n\n# equity_data is a PeriodicValues collector with equity history\ndf_summary = performance_summary_table(equity_data; periods_per_year=365)","category":"page"},{"location":"integrations/#NanoDates.jl","page":"Overview","title":"NanoDates.jl","text":"","category":"section"},{"location":"integrations/","page":"Overview","title":"Overview","text":"Fastback provides seamless integration to all Dates.AbstractTime types, which includes NanoDates.jl. NanoDates.jl provides nanosecond-resolution timestamps at the cost of a larger memory footprint (16 bytes vs. 8 bytes compared to DateTime). The representable date range is -146138511-01-01T00:22:22 to 146138805-04-11T23:47:15.","category":"page"},{"location":"integrations/","page":"Overview","title":"Overview","text":"Example: NanoDates integration walkthrough.","category":"page"},{"location":"integrations/#Timestamps64.jl","page":"Overview","title":"Timestamps64.jl","text":"","category":"section"},{"location":"integrations/","page":"Overview","title":"Overview","text":"Fastback provides seamless integration to all Dates.AbstractTime types, which includes Timestamps64.jl. Timestamps64.jl provides nanosecond-resolution timestamps without sacrificing performance. The Timestamp64 type has a smaller memory footprint (8 bytes vs. 16 bytes compared to NanoDate), and is faster for arithmetic operations. The representable date range is 1970-01-01T00:00:00 to 2262-04-11 23:47:16.","category":"page"},{"location":"integrations/","page":"Overview","title":"Overview","text":"Example: Timestamps64 integration walkthrough.","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"EditURL = \"../1_plots_extension.jl\"","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Jupyter Notebook: 1_plots_extension.ipynb","category":"page"},{"location":"plotting/gen/1_plots_extension/#Plots-extension-showcase","page":"Plots extensions","title":"Plots extension showcase","text":"","category":"section"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"This example demonstrates all plotting helpers provided by the Fastback Plots extension. It runs a small backtest to populate collectors, trades, and cashflows, then renders each plot type for illustration.","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"using Fastback\nusing Dates\nusing Plots\nusing CSV\nusing DataFrames\nusing Statistics","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Simple backtest to generate plot data","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"acc = Account(;\n    funding=AccountFunding.Margined,\n    base_currency=CashSpec(:USDT),\n    broker=BinanceBroker(; maker_derivatives=0.0004, taker_derivatives=0.0004),\n);\nusdt = cash_asset(acc, :USDT)\ndeposit!(acc, :USDT, 10_000.0)\nperp = register_instrument!(\n    acc,\n    perpetual_instrument(\n        Symbol(\"BTCUSDT-PERP\"),\n        :BTC,\n        :USDT;\n        margin_requirement=MarginRequirement.PercentNotional,\n        margin_init_long=0.10,\n        margin_init_short=0.10,\n        margin_maint_long=0.05,\n        margin_maint_short=0.05,\n    ),\n)\n\ncollect_balance, balance_data = periodic_collector(Float64, Hour(1));\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1));\ncollect_open, open_orders_data = periodic_collector(Int, Hour(1));\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(1));\ncollect_gross, gross_exposure = periodic_collector(Float64, Hour(1));\ncollect_net, net_exposure = periodic_collector(Float64, Hour(1));\ncollect_long, long_exposure = periodic_collector(Float64, Hour(1));\ncollect_short, short_exposure = periodic_collector(Float64, Hour(1));\n\n# load synthetic USD-M perp data\n# columns: dt, bid, ask, last, funding_rate\ndata_path = \"../data/usdm_perp_1h.csv\";\n\n# if data path doesn't exist, try to change working directory\nisfile(data_path) || cd(\"src/plotting\")\n\n# parse CSV (hourly rows)\ndf = DataFrame(CSV.File(data_path; dateformat=\"yyyy-mm-dd HH:MM:SS\"));\nsort!(df, :dt);\nn_steps = nrow(df);\n\nwindow = 24;\ndeadband = 0.002;\nleverage_target = 2.0;\n\nfor i in 1:n_steps\n    row = df[i, :]\n    dt = row.dt\n    bid = row.bid\n    ask = row.ask\n    last = row.last\n    funding_rate = row.funding_rate\n    marks = [MarkUpdate(perp.index, bid, ask, last)]\n    funding = funding_rate == 0.0 ? nothing : [FundingUpdate(perp.index, funding_rate)]\n    process_step!(acc, dt; marks=marks, funding=funding, liquidate=true)\n\n    if i >= window\n        ma = mean(@view df.last[i-window+1:i])\n        signal = last > (1 + deadband) * ma ? 1.0 : (last < (1 - deadband) * ma ? -1.0 : 0.0)\n\n        pos = get_position(acc, perp)\n        target_qty = signal == 0.0 ? 0.0 : signal * leverage_target * equity(acc, usdt) / last\n        delta_qty = target_qty - pos.quantity\n\n        if abs(delta_qty) > 1e-8\n            order = Order(oid!(acc), perp, dt, last, delta_qty)\n            fill_order!(acc, order; dt=dt, fill_price=last, bid=bid, ask=ask, last=last)\n        end\n    end\n\n    if should_collect(balance_data, dt)\n        collect_balance(dt, cash_balance(acc, usdt))\n        eq = equity(acc, usdt)\n        collect_equity(dt, eq)\n        collect_drawdown(dt, eq)\n        pos = get_position(acc, perp)\n        collect_open(dt, pos.quantity == 0.0 ? 0 : 1)\n        notional = pos.quantity * last * perp.multiplier\n        long_exp = max(notional, 0.0)\n        short_exp = min(notional, 0.0)\n        gross_exp = long_exp - short_exp\n        collect_gross(dt, gross_exp)\n        collect_net(dt, notional)\n        collect_long(dt, long_exp)\n        collect_short(dt, short_exp)\n    end\nend\n\npos = get_position(acc, perp)\nif pos.quantity != 0.0\n    row = df[end, :]\n    order = Order(oid!(acc), perp, row.dt, row.last, -pos.quantity)\n    fill_order!(acc, order; dt=row.dt, fill_price=row.last, bid=row.bid, ask=row.ask, last=row.last)\nend","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Basic plot helpers","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Balance plot","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_balance(balance_data)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Equity plot","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_equity(equity_data)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Equity plot (index x-axis)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_equity(equity_data; xaxis_mode=:index)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Open orders plot","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_open_orders_count(open_orders_data)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Open orders plot (index x-axis)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_open_orders_count(open_orders_data; xaxis_mode=:index)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Drawdown plot","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_drawdown(drawdown_data)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Drawdown plot (index x-axis)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_drawdown(drawdown_data; xaxis_mode=:index)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Exposure plot (gross, net, long, short)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_exposure(;\n    gross=gross_exposure,\n    net=net_exposure,\n    long=long_exposure,\n    short=short_exposure)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Equity + drawdown overlay","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_equity_drawdown(equity_data, drawdown_data)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Overlay helpers (plot_! variants)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"p = plot();\nFastback.plot_balance!(p, balance_data; title=\"Account\");\nFastback.plot_equity!(p, equity_data);\np\n\np = plot();\nFastback.plot_equity_drawdown!(p, equity_data, drawdown_data; title=\"Equity & drawdown\");\np","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Cashflow plots","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_cashflows(acc)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Return-based plots","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Gross returns by day (violin plot)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_violin_realized_returns_by_day(acc.trades; return_basis=:gross)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Net returns by hour (violin plot)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_violin_realized_returns_by_hour(acc.trades; return_basis=:net)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Cumulative net returns by hour","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_realized_cum_returns_by_hour(acc.trades; return_basis=:net)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Cumulative net returns by hour (index x-axis)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_realized_cum_returns_by_hour(acc.trades; return_basis=:net, xaxis_mode=:index)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Cumulative gross returns by weekday","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_realized_cum_returns_by_weekday(acc.trades; return_basis=:gross)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Cumulative gross returns by weekday (index x-axis)","category":"page"},{"location":"plotting/gen/1_plots_extension/","page":"Plots extensions","title":"Plots extensions","text":"Fastback.plot_realized_cum_returns_by_weekday(acc.trades; return_basis=:gross, xaxis_mode=:index)","category":"page"},{"location":"#Fastback.jl-Blazingly-fast-Julia-backtester","page":"Home","title":"Fastback.jl - Blazingly fast Julia backtester 🚀","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: License) (Image: Maintenance) (Image: Documentation)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fastback provides a lightweight, flexible and highly efficient event-based backtesting library for quantitative trading strategies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fastback focuses on deterministic accounting: it tracks open positions, balances, equity, margin, and cashflows across multiple currencies. The execution pipeline supports broker-driven commissions/financing and partial fills; slippage and delays are modeled by the timestamps and fill prices you pass in.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fastback does not try to model every aspect of a trading system, e.g. data ingestion, strategy logic, OMS/execution gateways, or logging. Instead, it provides basic building blocks for creating a custom backtesting environment that is easy to understand and extend. Broker behavior is intentionally lightweight and pluggable via broker profiles (for commissions and financing schedules). For example, Fastback has no notion of \"strategy\" or \"indicator\"; such constructs are highly strategy specific, and therefore up to the user to define.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The event-based architecture aims to mimic how real-world trading systems ingest streaming data. You drive the engine with explicit mark, FX, and funding updates, plus optional expiry and liquidation steps, which reduces the implementation gap to live execution compared to vectorized backtesting frameworks.","category":"page"},{"location":"#Hello-world-backtest","page":"Home","title":"Hello world backtest","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Fastback\nusing Dates\n\nacc = Account(;\n    broker=FlatFeeBroker(pct=0.001),\n    funding=AccountFunding.FullyFunded,\n    base_currency=CashSpec(:USD),\n)\nusd = cash_asset(acc, :USD)\ndeposit!(acc, usd, 10_000.0)\ninst = register_instrument!(acc, spot_instrument(:ABC, :ABC, :USD))\n\ndts = [DateTime(2024, 1, 1) + Hour(i) for i in 0:3]\nprices = [100.0, 101.0, 102.0, 101.5]\n\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1))\n\nfor (dt, price) in zip(dts, prices)\n    update_marks!(acc, inst, dt, price, price, price)\n    if dt == dts[1]\n        order = Order(oid!(acc), inst, dt, price, 10.0)\n        fill_order!(acc, order; dt=dt, fill_price=price, bid=price, ask=price, last=price)\n    elseif dt == dts[end]\n        pos = get_position(acc, inst)\n        order = Order(oid!(acc), inst, dt, price, -pos.quantity)\n        fill_order!(acc, order; dt=dt, fill_price=price, bid=price, ask=price, last=price)\n    end\n\n    if should_collect(equity_data, dt)\n        collect_equity(dt, equity(acc, usd))\n    end\nend\n\nequity(acc, usd)\n\n# Plots (requires Plots.jl)\nusing Plots\nFastback.plot_equity(equity_data)","category":"page"},{"location":"","page":"Home","title":"Home","text":"See Getting started for a runnable walkthrough and next steps.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Event-driven accounting engine with explicit event processing (process_step!) for marks, FX, funding, expiries, and optional liquidation\nInstruments: spot (including spot-on-margin), perpetuals, and futures with lifecycle guards (start/expiry), optional contract multipliers, and settlement styles (PrincipalExchange/VariationMargin)\nFunding policies: fully funded or margined; per-currency or base-currency margin aggregation; percent-notional or fixed-per-contract margin requirements\nBroker profiles for commissions/financing (e.g. flat-fee, IBKR-style, Binance-style)\nMulti-currency cash book with FX conversion helpers and base-currency metrics\nExecution & risk: broker-driven commissions, partial fills, liquidation-aware marking (bid/ask/last), and initial/maintenance margin checks\nNetted positions with weighted-average cost, realized/unrealized P&L, and a cashflow ledger + accrual helpers (lend/borrow interest, broker-defined short-proceeds treatment, borrow fees on principal-exchange spot shorts, funding, variation margin)\nExpiry handling for futures (auto-close via synthetic close) plus deterministic liquidation helpers\nCollectors (periodic, predicate, drawdown, min/max) and Tables.jl views for balances, equity, positions, trades, cashflows; pretty-print helpers\nBatch backtesting and parameter sweeps with threaded runner and ETA logging\nIntegrations\nPlots.jl and StatsPlots.jl for optional visualization helpers (via FastbackPlotsExt)\nNanoDates.jl for nanosecond timestamps\nTimestamps64.jl for efficient nanosecond timestamps","category":"page"},{"location":"#Documentation-and-Examples","page":"Home","title":"Documentation & Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full documentation and examples are available at Fastback.jl documentation page.","category":"page"},{"location":"#Changelog","page":"Home","title":"Changelog","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the CHANGELOG.","category":"page"},{"location":"#Bug-reports-and-feature-requests","page":"Home","title":"Bug reports and feature requests","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please report any issues via the GitHub issue tracker.","category":"page"},{"location":"integrations/gen/2_NanoDates_integration/","page":"NanoDates.jl","title":"NanoDates.jl","text":"EditURL = \"../2_NanoDates_integration.jl\"","category":"page"},{"location":"integrations/gen/2_NanoDates_integration/","page":"NanoDates.jl","title":"NanoDates.jl","text":"Jupyter Notebook: 2_NanoDates_integration.ipynb","category":"page"},{"location":"integrations/gen/2_NanoDates_integration/#NanoDates-integration-example","page":"NanoDates.jl","title":"NanoDates integration example","text":"","category":"section"},{"location":"integrations/gen/2_NanoDates_integration/","page":"NanoDates.jl","title":"NanoDates.jl","text":"This example shows how to pair Fastback's timestamp parametrization with high-resolution NanoDate values from NanoDates.jl. It is derived from the random trading walkthrough but focuses on exercising the integration, so plotting has been omitted.","category":"page"},{"location":"integrations/gen/2_NanoDates_integration/","page":"NanoDates.jl","title":"NanoDates.jl","text":"using Fastback\nusing Dates\nusing NanoDates\nusing Random\n\n# set RNG seed for reproducibility\nRandom.seed!(42);\n\n# generate synthetic price series\nN = 2_000\nprices = 1000.0 .+ cumsum(randn(N) .+ 0.1)\nstart_dt = NanoDate(2020, 1, 1)\ndts = [start_dt + Hour(i) for i in 0:N-1]\n\n# create trading account with $10'000 start capital and NanoDate support (margin-enabled for shorting)\nacc = Account(;\n    time_type=NanoDate,\n    funding=AccountFunding.Margined,\n    base_currency=CashSpec(:USD),\n    broker=FlatFeeBroker(; pct=0.001),\n)\nusd = cash_asset(acc, :USD)\ndeposit!(acc, :USD, 10_000.0)\n\n# register a dummy instrument\nDUMMY = register_instrument!(acc, spot_instrument(Symbol(\"DUMMY/USD\"), :DUMMY, :USD; time_type=NanoDate))\n\n# data collector for account equity and drawdowns (sampling every hour)\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1); time_type=NanoDate)\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(1); time_type=NanoDate)\n\n# loop over price series\nfor (dt, price) in zip(dts, prices)\n    # randomly trade with 1% probability\n    if rand() < 0.01\n        quantity = rand() > 0.4 ? 1.0 : -1.0\n        order = Order(oid!(acc), DUMMY, dt, price, quantity)\n        fill_order!(acc, order; dt=dt, fill_price=price, bid=price, ask=price, last=price, fill_qty=0.75order.quantity)\n    end\n\n    # update position and account P&L\n    update_marks!(acc, DUMMY, dt, price, price, price)\n\n    # collect data for analysis\n    if should_collect(equity_data, dt)\n        equity_value = equity(acc, usd)\n        collect_equity(dt, equity_value)\n        collect_drawdown(dt, equity_value)\n    end\nend\n\n# print account summary\nshow(acc)","category":"page"}]
}
