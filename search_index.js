var documenterSearchIndex = {"docs":
[{"location":"examples/gen/1_random_trading/","page":"1. Random trading","title":"1. Random trading","text":"EditURL = \"../1_random_trading.jl\"","category":"page"},{"location":"examples/gen/1_random_trading/#Random-trading-strategy-example","page":"1. Random trading","title":"Random trading strategy example","text":"","category":"section"},{"location":"examples/gen/1_random_trading/","page":"1. Random trading","title":"1. Random trading","text":"This dummy example demonstrates how to backtest a simple random trading strategy using synthetic data generated in the script. The price series is a random walk with a drift of 0.1 and initial price 1000.","category":"page"},{"location":"examples/gen/1_random_trading/","page":"1. Random trading","title":"1. Random trading","text":"The strategy randomly buys or sells an instrument with a probability of 1%. Buy and sell orders use the same price series, implying a spread of 0. Each trade is executed at a commission of 0.1%. For the sake of illustration, only 75% of the order quantity is filled.","category":"page"},{"location":"examples/gen/1_random_trading/","page":"1. Random trading","title":"1. Random trading","text":"The account equity and drawdowns are collected for every hour and plotted at the end using the Plots package.","category":"page"},{"location":"examples/gen/1_random_trading/","page":"1. Random trading","title":"1. Random trading","text":"using Fastback\nusing Dates\nusing Random\n\n# set RNG seed for reproducibility\nRandom.seed!(42);\n\n# generate synthetic price series\nN = 2_000;\nprices = 1000.0 .+ cumsum(randn(N) .+ 0.1);\ndts = map(x -> DateTime(2020, 1, 1) + Hour(x), 0:N-1);\n\n# create trading account with $10'000 start capital\nacc = Account();\ndeposit!(acc, Cash(:USD), 10_000.0);\n\n# register a dummy instrument\nDUMMY = register_instrument!(acc, Instrument(Symbol(\"DUMMY/USD\"), :DUMMY, :USD))\n\n# data collector for account equity and drawdowns (sampling every hour)\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1));\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(1));\n\n# loop over price series\nfor (dt, price) in zip(dts, prices)\n    # randomly trade with 1% probability\n    if rand() < 0.01\n        quantity = rand() > 0.4 ? 1.0 : -1.0\n        order = Order(oid!(acc), DUMMY, dt, price, quantity)\n        fill_order!(acc, order, dt, price; fill_qty=0.75order.quantity, commission_pct=0.001)\n    end\n\n    # update position and account P&L\n    update_pnl!(acc, DUMMY, price, price)\n\n    # collect data for plotting\n    if should_collect(equity_data, dt)\n        equity_value = equity(acc, :USD)\n        collect_equity(dt, equity_value)\n        collect_drawdown(dt, equity_value)\n    end\nend\n\n# print account summary\nshow(acc)","category":"page"},{"location":"examples/gen/1_random_trading/#Plot-account-equity-curve","page":"1. Random trading","title":"Plot account equity curve","text":"","category":"section"},{"location":"examples/gen/1_random_trading/","page":"1. Random trading","title":"1. Random trading","text":"using Plots, Printf\ntheme(:juno; titlelocation=:left, titlefontsize=10, widen=false, fg_legend=:false)\n\n# plot equity curve\np = plot(dates(equity_data), values(equity_data);\n    title=\"Account\",\n    label=\"Equity\",\n    linetype=:steppost,\n    yformatter=:plain,\n    size=(800, 400),\n    color=\"#BBBB00\");\np","category":"page"},{"location":"examples/gen/1_random_trading/#Plot-account-equity-drawdown-curve","page":"1. Random trading","title":"Plot account equity drawdown curve","text":"","category":"section"},{"location":"examples/gen/1_random_trading/","page":"1. Random trading","title":"1. Random trading","text":"# plot drawdown curve\np = plot(dates(drawdown_data), 100values(drawdown_data);\n    title=\"Equity drawdowns [%]\",\n    legend=false,\n    linetype=:steppost,\n    color=\"#BB0000\",\n    yformatter=y -> @sprintf(\"%.1f%%\", y),\n    size=(800, 200),\n    fill=(0, \"#BB000033\"));\np","category":"page"},{"location":"examples/gen/7_Timestamps64_integration/","page":"7. Timestamps64.jl integration","title":"7. Timestamps64.jl integration","text":"EditURL = \"../7_Timestamps64_integration.jl\"","category":"page"},{"location":"examples/gen/7_Timestamps64_integration/#Timestamps64-integration-example","page":"7. Timestamps64.jl integration","title":"Timestamps64 integration example","text":"","category":"section"},{"location":"examples/gen/7_Timestamps64_integration/","page":"7. Timestamps64.jl integration","title":"7. Timestamps64.jl integration","text":"This example shows how to pair Fastback's timestamp parametrization with high-resolution Timestamp64 values from Timestamps64.jl.","category":"page"},{"location":"examples/gen/7_Timestamps64_integration/","page":"7. Timestamps64.jl integration","title":"7. Timestamps64.jl integration","text":"Timestamps64.jl provides nanosecond-resolution timestamps based on Int64 values, which makes them very efficient in terms of memory and performance. They are particularly useful for high-frequency trading applications. Compared to NanoDates.jl, Timestamps64.jl has a smaller memory footprint (8 bytes vs. 16 bytes), and is faster for arithmetic operations.","category":"page"},{"location":"examples/gen/7_Timestamps64_integration/","page":"7. Timestamps64.jl integration","title":"7. Timestamps64.jl integration","text":"This example is derived from the random trading walkthrough but focuses on exercising the integration, so plotting has been omitted.","category":"page"},{"location":"examples/gen/7_Timestamps64_integration/","page":"7. Timestamps64.jl integration","title":"7. Timestamps64.jl integration","text":"using Fastback\nusing Dates\nusing Timestamps64\nusing Random\n\n# set RNG seed for reproducibility\nRandom.seed!(42);\n\n# generate synthetic price series\nN = 2_000\nprices = 1000.0 .+ cumsum(randn(N) .+ 0.1)\nstart_dt = Timestamp64(2020, 1, 1)\ndts = [start_dt + Hour(i) for i in 0:N-1]\n\n# create trading account with $10'000 start capital and Timestamp64 support\nacc = Account(; time_type=Timestamp64)\ndeposit!(acc, Cash(:USD), 10_000.0)\n\n# register a dummy instrument\nDUMMY = register_instrument!(acc, Instrument(Symbol(\"DUMMY/USD\"), :DUMMY, :USD))\n\n# data collector for account equity and drawdowns (sampling every hour)\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1); time_type=Timestamp64)\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(1); time_type=Timestamp64)\n\n# loop over price series\nfor (dt, price) in zip(dts, prices)\n    # randomly trade with 1% probability\n    if rand() < 0.01\n        quantity = rand() > 0.4 ? 1.0 : -1.0\n        order = Order(oid!(acc), DUMMY, dt, price, quantity)\n        fill_order!(acc, order, dt, price; fill_qty=0.75order.quantity, commission_pct=0.001)\n    end\n\n    # update position and account P&L\n    update_pnl!(acc, DUMMY, price, price)\n\n    # collect data for analysis\n    if should_collect(equity_data, dt)\n        equity_value = equity(acc, :USD)\n        collect_equity(dt, equity_value)\n        collect_drawdown(dt, equity_value)\n    end\nend\n\n# print account summary\nshow(acc)","category":"page"},{"location":"examples/gen/6_NanoDates_integration/","page":"6. NanoDates.jl integration","title":"6. NanoDates.jl integration","text":"EditURL = \"../6_NanoDates_integration.jl\"","category":"page"},{"location":"examples/gen/6_NanoDates_integration/#NanoDates-integration-example","page":"6. NanoDates.jl integration","title":"NanoDates integration example","text":"","category":"section"},{"location":"examples/gen/6_NanoDates_integration/","page":"6. NanoDates.jl integration","title":"6. NanoDates.jl integration","text":"This example shows how to pair Fastback's timestamp parametrization with high-resolution NanoDate values from NanoDates.jl. It is derived from the random trading walkthrough but focuses on exercising the integration, so plotting has been omitted.","category":"page"},{"location":"examples/gen/6_NanoDates_integration/","page":"6. NanoDates.jl integration","title":"6. NanoDates.jl integration","text":"using Fastback\nusing Dates\nusing NanoDates\nusing Random\n\n# set RNG seed for reproducibility\nRandom.seed!(42);\n\n# generate synthetic price series\nN = 2_000\nprices = 1000.0 .+ cumsum(randn(N) .+ 0.1)\nstart_dt = NanoDate(2020, 1, 1)\ndts = [start_dt + Hour(i) for i in 0:N-1]\n\n# create trading account with $10'000 start capital and NanoDate support\nacc = Account(; time_type=NanoDate)\ndeposit!(acc, Cash(:USD), 10_000.0)\n\n# register a dummy instrument\nDUMMY = register_instrument!(acc, Instrument(Symbol(\"DUMMY/USD\"), :DUMMY, :USD))\n\n# data collector for account equity and drawdowns (sampling every hour)\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1); time_type=NanoDate)\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(1); time_type=NanoDate)\n\n# loop over price series\nfor (dt, price) in zip(dts, prices)\n    # randomly trade with 1% probability\n    if rand() < 0.01\n        quantity = rand() > 0.4 ? 1.0 : -1.0\n        order = Order(oid!(acc), DUMMY, dt, price, quantity)\n        fill_order!(acc, order, dt, price; fill_qty=0.75order.quantity, commission_pct=0.001)\n    end\n\n    # update position and account P&L\n    update_pnl!(acc, DUMMY, price, price)\n\n    # collect data for analysis\n    if should_collect(equity_data, dt)\n        equity_value = equity(acc, :USD)\n        collect_equity(dt, equity_value)\n        collect_drawdown(dt, equity_value)\n    end\nend\n\n# print account summary\nshow(acc)","category":"page"},{"location":"examples/gen/3_multi_currency/","page":"3. Multi-Currency trading","title":"3. Multi-Currency trading","text":"EditURL = \"../3_multi_currency.jl\"","category":"page"},{"location":"examples/gen/3_multi_currency/#Multi-currency-trading-example","page":"3. Multi-Currency trading","title":"Multi-currency trading example","text":"","category":"section"},{"location":"examples/gen/3_multi_currency/","page":"3. Multi-Currency trading","title":"3. Multi-Currency trading","text":"This example demonstrates how to trade assets quoted in different currencies. The account has balances in USD, EUR and GBP, and trades stocks denoted in those currencies. The total equity is calculated in USD. A spot exchange rate helper is used to convert between different currencies.","category":"page"},{"location":"examples/gen/3_multi_currency/","page":"3. Multi-Currency trading","title":"3. Multi-Currency trading","text":"using Fastback\nusing Dates\nusing Random\nusing DataFrames\n\n# set RNG seed for reproducibility\nRandom.seed!(42);\n\n# generate synthetic price series for Tesla (USD), Porsche (EUR) and Tesco (GBP)\nN = 2_000;\ndf = DataFrame([\n    :date => map(x -> DateTime(2020, 1, 1) + Hour(x), 0:N-1),\n    :TSLA => 170 .+ cumsum(randn(N) .+ 0.12),\n    :POAHY => 4.5 .+ cumsum(randn(N) .+ 0.02),\n    :TSCO_L => 307 .+ cumsum(randn(N) .+ 0.08)\n]);\n\n# create cash objects for USD, EUR and GBP\nUSD = Cash(:USD; digits=2);\nEUR = Cash(:EUR; digits=2);\nGBP = Cash(:GBP; digits=2);\n\n# create trading account with 10'000 USD, 5'000 EUR and 20'000 GBP cash\nacc = Account();\ndeposit!(acc, USD, 10_000);\ndeposit!(acc, EUR, 5_000);\ndeposit!(acc, GBP, 20_000);\n\n# exchange rates for spot rates\ner = SpotExchangeRates();\n\n# set spot exchange rates once\nadd_asset!(er, USD);\nadd_asset!(er, EUR);\nadd_asset!(er, GBP);\nupdate_rate!(er, EUR, USD, 1.07);\nupdate_rate!(er, GBP, USD, 1.27);\n\nshow(er)\n\n# register stock instruments\ninstruments = [\n    register_instrument!(acc, Instrument(:TSLA, :TSLA, :USD)), # Tesla (USD denominated)\n    register_instrument!(acc, Instrument(:POAHY, :POAHY, :EUR)), # Porsche (EUR denominated)\n    register_instrument!(acc, Instrument(:TSCO_L, :TSCO_L, :GBP)), # Tesco (GBP denominated)\n];\n\n# data collector for account equity and drawdowns (sampling every hour)\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1));\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(1));\n\n# loop over price series\nfor i in 1:N\n    dt = df.date[i]\n\n    # randomly trade with 1% probability\n    if rand() < 0.01\n        inst = rand(instruments)\n        price = df[i, inst.symbol]\n        quantity = rand() > 0.5 ? 10.0 : -10.0\n        order = Order(oid!(acc), inst, dt, price, quantity)\n        fill_order!(acc, order, dt, price; commission_pct=0.001)\n    end\n\n    # update position and account P&L\n    for inst in instruments\n        price = df[i, inst.symbol]\n        update_pnl!(acc, inst, price, price)\n    end\n\n    # collect data for plotting\n    if should_collect(equity_data, dt)\n        total_equity = (\n            equity(acc, :USD) +\n            equity(acc, :EUR) * get_rate(er, EUR, USD) +\n            equity(acc, :GBP) * get_rate(er, GBP, USD)\n        )\n        collect_equity(dt, total_equity)\n        collect_drawdown(dt, total_equity)\n    end\nend\n\n# print account summary\nshow(acc)","category":"page"},{"location":"examples/gen/3_multi_currency/#Plot-account-equity-curve","page":"3. Multi-Currency trading","title":"Plot account equity curve","text":"","category":"section"},{"location":"examples/gen/3_multi_currency/","page":"3. Multi-Currency trading","title":"3. Multi-Currency trading","text":"using Plots, Printf\ntheme(:juno; titlelocation=:left, titlefontsize=10, widen=false, fg_legend=:false)\n\n# plot equity curve\np = plot(dates(equity_data), values(equity_data);\n    title=\"Account\",\n    label=\"Equity\",\n    linetype=:steppost,\n    yformatter=:plain,\n    size=(800, 400),\n    color=\"#BBBB00\");\np","category":"page"},{"location":"examples/gen/3_multi_currency/#Plot-account-equity-drawdown-curve","page":"3. Multi-Currency trading","title":"Plot account equity drawdown curve","text":"","category":"section"},{"location":"examples/gen/3_multi_currency/","page":"3. Multi-Currency trading","title":"3. Multi-Currency trading","text":"# plot drawdown curve\np = plot(dates(drawdown_data), 100values(drawdown_data);\n    title=\"Equity drawdowns [%]\",\n    legend=false,\n    linetype=:steppost,\n    color=\"#BB0000\",\n    yformatter=y -> @sprintf(\"%.1f%%\", y),\n    size=(800, 200),\n    fill=(0, \"#BB000033\"));\np","category":"page"},{"location":"basic_setup/#Fastback-basic-backtest-setup","page":"Basic setup","title":"Fastback basic backtest setup","text":"","category":"section"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"A backtest using Fastback usually consists of the following parts:","category":"page"},{"location":"basic_setup/#1.-Data","page":"Basic setup","title":"1. Data","text":"","category":"section"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"Acquire data like price, volume and other featuers you want to backtest on. This can be from a DataFrame, a CSV file, or a database. Ideally, it can be looped over, or streamed efficiently.","category":"page"},{"location":"basic_setup/#2.-Account","page":"Basic setup","title":"2. Account","text":"","category":"section"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"Initialize the account you want to backtest with. The account holds the assets (funds), positions, trades, and does all the bookkeeping. Fund the account with deposit!(account, cash_asset, amount) and reduce balances later with withdraw! when simulating outflows.","category":"page"},{"location":"basic_setup/#3.-Instruments","page":"Basic setup","title":"3. Instruments","text":"","category":"section"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"Register the instruments you want to trade with, e.g. stocks or cryptocurrencies. Instruments specify the display symbol, base- and quote symbols, tick sizes and valid value ranges.","category":"page"},{"location":"basic_setup/#4.-Data-collectors","page":"Basic setup","title":"4. Data collectors","text":"","category":"section"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"Initialize data collectors for account balance, equity, drawdowns, etc. Data collectors are not required, but help in collecting data for further analysis of the backtest results.","category":"page"},{"location":"basic_setup/#5.-Trading-logic","page":"Basic setup","title":"5. Trading logic","text":"","category":"section"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"Implement the actual trading logic you want to backtest, i.e. the strategy. It is called at every iteration of the input data and takes trading decisions like buying or selling instruments. In a live-setting, the data would be streamed to the trading logic instead of being looped over.","category":"page"},{"location":"basic_setup/#6.-Analysis","page":"Basic setup","title":"6. Analysis","text":"","category":"section"},{"location":"basic_setup/","page":"Basic setup","title":"Basic setup","text":"Analyze the backtest results by inspecing the account and the collected data. Print account balances, equity, drawdowns, etc., or create plots. Alternatively, store the results in a Vector or DataFrame for further analysis.For example, when running an optimization, we compute the metric of interest and store it in a Vector or similar. At the end of the optimization, we can then inspect the results and find the best parameters.","category":"page"},{"location":"glossary/#Glossary","page":"Glossary","title":"Glossary","text":"","category":"section"},{"location":"glossary/#Account","page":"Glossary","title":"Account","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Account is Fastback's central ledger. It keeps the registered cash assets, open positions, executed trades, account-level balances and equities, along with order and trade sequence counters. Construction and mutation helpers such as register_cash_asset!, register_instrument!, deposit!, withdraw!, and fill_order! are provided by the account API.","category":"page"},{"location":"glossary/#Order","page":"Glossary","title":"Order","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"An Order encapsulates an instruction to trade an instrument at a specific time, price, and quantity, with optional take_profit and stop_loss levels and metadata. Orders translate into trades through fill_order!.","category":"page"},{"location":"glossary/#Trade","page":"Glossary","title":"Trade","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A Trade records the actual execution of an order, including fill price, filled and remaining quantity, realized P&L, realized quantity, commission, and the pre-trade position state. Trades accumulate in Account.trades.","category":"page"},{"location":"glossary/#Position","page":"Glossary","title":"Position","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A Position maintains the net exposure for an instrument using a weighted-average cost basis. It stores the average price, quantity, and unrealized P&L (pnl_local), and powers helpers like calc_pnl_local and calc_return_local. Positions are stored in Account.positions.","category":"page"},{"location":"glossary/#Instrument","page":"Glossary","title":"Instrument","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Instrument models a tradable product, binding together the display symbol, base asset settings, quote asset settings, and optional metadata. Instruments must be registered with an account before use using the register_instrument! function.","category":"page"},{"location":"glossary/#Base-Asset","page":"Glossary","title":"Base Asset","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"The base asset represents the tradable quantity of an instrument (e.g. shares, contracts, coins). Instruments define their base symbol, tick size, min/max quantity, and display precision via base_symbol, base_tick, base_min, base_max, and base_digits.","category":"page"},{"location":"glossary/#Price","page":"Glossary","title":"Price","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Price is a type alias for Float64 used for quote-currency values—trade prices, commissions, P&L figures, and so on. Quote precision and tick sizes are instrument-defined.","category":"page"},{"location":"glossary/#Quantity","page":"Glossary","title":"Quantity","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Quantity is a type alias for Float64 describing position or order size. Positive quantities represent long exposure; negative quantities represent short exposure across orders, trades, and positions.","category":"page"},{"location":"glossary/#Exposure","page":"Glossary","title":"Exposure","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Exposure is the signed quantity of an open position. Helper predicates such as has_exposure, is_long, is_short, and trade_dir determine exposure state for Positions and Accounts.","category":"page"},{"location":"glossary/#Fill","page":"Glossary","title":"Fill","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A fill is the execution of an order (whole or partial). fill_order! creates a Trade with the fill price, fill quantity, remaining quantity, and realized P&L.","category":"page"},{"location":"glossary/#Commission","page":"Glossary","title":"Commission","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Commission captures execution costs in the quote currency. fill_order! supports both fixed commissions and percentage-based fees (commission_pct), applying them to balances, equities, and realized P&L.","category":"page"},{"location":"glossary/#Realized-P-and-L","page":"Glossary","title":"Realized P&L","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Realized P&L is produced when exposure decreases. fill_order! computes realized P&L via calc_realized_qty, credits it to the account balance, subtracts commissions, and resets the position's P&L accordingly.","category":"page"},{"location":"glossary/#Unrealized-P-and-L","page":"Glossary","title":"Unrealized P&L","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Unrealized P&L (stored as pnl_local on a Position) reflects the floating profit or loss based on the current mark price. update_pnl! keeps it in sync and mirrors the change into account equity without touching balances.","category":"page"},{"location":"glossary/#Trade-Direction","page":"Glossary","title":"Trade Direction","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"TradeDir is the @enumx representing trade direction: Buy, Sell, or Null. Conversion helpers such as trade_dir(quantity), is_long, is_short, and opposite_dir provide directional logic across orders, trades, and positions.","category":"page"},{"location":"glossary/#Balance","page":"Glossary","title":"Balance","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A balance is the cash-only value associated with a Cash asset. Deposits, withdrawals, commissions, and realized P&L update balances; floating P&L from open positions does not. Access balances through cash_balance(acc, cash).","category":"page"},{"location":"glossary/#Equity","page":"Glossary","title":"Equity","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Equity is the balance of a cash asset plus the unrealized P&L of open positions denominated in that currency. Access equities through equity(acc, cash).","category":"page"},{"location":"glossary/#Cash-Asset","page":"Glossary","title":"Cash Asset","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"A Cash object models a funding currency (USD, EUR, BTC, …) with display precision and optional metadata. Cash assets must be registered with an account before funds can be deposited or withdrawn using the register_cash_asset! function.","category":"page"},{"location":"glossary/#Collector","page":"Glossary","title":"Collector","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Collectors are lightweight recorders that capture time-series or summary statistics during a backtest. periodic_collector, predicate_collector, drawdown_collector, and helpers like min_value_collector are part of the collectors API and return both the collecting closure and the mutable storage.","category":"page"},{"location":"glossary/#Exchange-Rate","page":"Glossary","title":"Exchange Rate","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"Exchange-rate providers convert values between cash assets. OneExchangeRates always returns 1.0, while SpotExchangeRates maintains a mutable matrix of pairwise rates and their inverses.","category":"page"},{"location":"glossary/#Batch-Backtest","page":"Glossary","title":"Batch Backtest","text":"","category":"section"},{"location":"glossary/","page":"Glossary","title":"Glossary","text":"batch_backtest runs a vector of parameter sets across one backtest function, optionally multi-threaded, while reporting progress and optional callbacks.","category":"page"},{"location":"examples/gen/4_metadata/","page":"4. Attach metadata","title":"4. Attach metadata","text":"EditURL = \"../4_metadata.jl\"","category":"page"},{"location":"examples/gen/4_metadata/#Attach-metadata-to-instruments-and-orders","page":"4. Attach metadata","title":"Attach metadata to instruments and orders","text":"","category":"section"},{"location":"examples/gen/4_metadata/","page":"4. Attach metadata","title":"4. Attach metadata","text":"This example, based on Random trading strategy example, demonstrates how to add metadata to instruments and orders. This is useful for attaching additional information to instruments and orders, such as instrument names, descriptions, or custom attributes, e.g. for storing the signal, strategy, or model that generated the order.","category":"page"},{"location":"examples/gen/4_metadata/","page":"4. Attach metadata","title":"4. Attach metadata","text":"The type of the metadata can be arbitrarily defined by the user, and is typesafe for best performance.","category":"page"},{"location":"examples/gen/4_metadata/","page":"4. Attach metadata","title":"4. Attach metadata","text":"The Account type has the following three type parameters:","category":"page"},{"location":"examples/gen/4_metadata/","page":"4. Attach metadata","title":"4. Attach metadata","text":"OData: Order metadata type\nIData: Instrument metadata type\nCData: Cash metadata type","category":"page"},{"location":"examples/gen/4_metadata/","page":"4. Attach metadata","title":"4. Attach metadata","text":"by default, these are set to Nothing, but can be customized to any type.","category":"page"},{"location":"examples/gen/4_metadata/","page":"4. Attach metadata","title":"4. Attach metadata","text":"In this example, we define custom types OData for order metadata, and IData for instrument metadata. The order metadata type OData has a single field probability::Float64, and the instrument metadata type IData has a single field full_name::String.","category":"page"},{"location":"examples/gen/4_metadata/","page":"4. Attach metadata","title":"4. Attach metadata","text":"using Fastback\nusing Dates\nusing Random\nusing Printf\n\n# set RNG seed for reproducibility\nRandom.seed!(42);\n\n# metadata type for orders\nstruct OData\n    probability::Float64\nend\n\nfunction Base.show(io::IO, o::OData)\n    print(io, @sprintf(\"probability=%.2f\", o.probability))\nend\n\n# metadata type for instruments\nstruct IData\n    full_name::String\nend\n\nfunction Base.show(io::IO, o::IData)\n    print(io, \"full_name=$(o.full_name)\")\nend\n\n# generate synthetic price series\nN = 2_000;\nprices = 1000.0 .+ cumsum(randn(N) .+ 0.1);\ndts = map(x -> DateTime(2020, 1, 1) + Hour(x), 0:N-1);\n\n# create trading account with $10'000 start capital\nacc = Account(; odata=OData, idata=IData);\ndeposit!(acc, Cash(:USD), 10_000.0);\n\n# register a dummy instrument\nDUMMY = register_instrument!(acc, Instrument(Symbol(\"DUMMY/USD\"), :DUMMY, :USD;\n    metadata=IData(\"Dummy instrument name\")));\n\n# data collector for account equity and drawdowns (sampling every hour)\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1));\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(1));\n\n# loop over price series\nfor (dt, price) in zip(dts, prices)\n    # randomly trade with 1% probability\n    if rand() < 0.01\n        prob = rand()\n        quantity = prob > 0.4 ? 1.0 : -1.0\n        order = Order(oid!(acc), DUMMY, dt, price, quantity; metadata=OData(prob))\n        fill_order!(acc, order, dt, price; fill_qty=0.75order.quantity, commission_pct=0.001)\n    end\n\n    # update position and account P&L\n    update_pnl!(acc, DUMMY, price, price)\n\n    # collect data for plotting\n    if should_collect(equity_data, dt)\n        equity_value = equity(acc, :USD)\n        collect_equity(dt, equity_value)\n        collect_drawdown(dt, equity_value)\n    end\nend","category":"page"},{"location":"examples/gen/4_metadata/#Print-instrument-incl.-metadata-to-console","page":"4. Attach metadata","title":"Print instrument incl. metadata to console","text":"","category":"section"},{"location":"examples/gen/4_metadata/","page":"4. Attach metadata","title":"4. Attach metadata","text":"Note that at the end, metadata is printed based on the show method defined above for IData type.","category":"page"},{"location":"examples/gen/4_metadata/","page":"4. Attach metadata","title":"4. Attach metadata","text":"show(DUMMY)","category":"page"},{"location":"examples/gen/4_metadata/#Print-account-summary-incl.-metadata-to-console","page":"4. Attach metadata","title":"Print account summary incl. metadata to console","text":"","category":"section"},{"location":"examples/gen/4_metadata/","page":"4. Attach metadata","title":"4. Attach metadata","text":"Note that at the end of the Trades table, a Metadata column is shown based on the show method defined above for OData type.","category":"page"},{"location":"examples/gen/4_metadata/","page":"4. Attach metadata","title":"4. Attach metadata","text":"show(acc)","category":"page"},{"location":"integrations/#Integrations","page":"Integrations","title":"Integrations","text":"","category":"section"},{"location":"integrations/#Tables.jl","page":"Integrations","title":"Tables.jl","text":"","category":"section"},{"location":"integrations/","page":"Integrations","title":"Integrations","text":"Fastback ships with zero-copy views that make every major account artefact available through the Tables.jl interface. That means you can hand results straight to DataFrames.jl, CSV.jl, Arrow.jl, or any other package that consumes Tables-compatible sources.","category":"page"},{"location":"integrations/","page":"Integrations","title":"Integrations","text":"Example see 5Tablesintegration.jl.","category":"page"},{"location":"integrations/#Account","page":"Integrations","title":"Account","text":"","category":"section"},{"location":"integrations/","page":"Integrations","title":"Integrations","text":"accessor description\ntrades_table(acc) All executed trades with order, execution, and metadata fields\npositions_table(acc) Current positions\nbalances_table(acc) Cash balances per currency, preserving custom cash metadata\nequities_table(acc) Equity values per currency","category":"page"},{"location":"integrations/","page":"Integrations","title":"Integrations","text":"using DataFrames\nusing Fastback\n\ndf_trades = DataFrame(trades_table(acc))\ndf_positions = DataFrame(positions_table(acc))\ndf_balances = DataFrame(balances_table(acc))\ndf_equities = DataFrame(equities_table(acc))","category":"page"},{"location":"integrations/","page":"Integrations","title":"Integrations","text":"All helpers return read-through views, so changes to the underlying account are visible immediately without copying.","category":"page"},{"location":"integrations/#Collectors","page":"Integrations","title":"Collectors","text":"","category":"section"},{"location":"integrations/","page":"Integrations","title":"Integrations","text":"Time-series collectors already satisfy the Tables.jl contract, so you can hand them directly to downstream packages. Drawdown collectors behave the same way, preserving the configured mode in each row.","category":"page"},{"location":"integrations/","page":"Integrations","title":"Integrations","text":"using Dates\nusing DataFrames\nusing Fastback\n\ncollect_equity, equity_data = periodic_collector(Float64, Hour(1))\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(1))\n\n# ... run backtest and collect values ...\n\ndf_equity_history = DataFrame(equity_data)\ndf_drawdown_history = DataFrame(drawdown_data)","category":"page"},{"location":"integrations/#NanoDates.jl","page":"Integrations","title":"NanoDates.jl","text":"","category":"section"},{"location":"integrations/","page":"Integrations","title":"Integrations","text":"Fastback provides seamless integration to all Dates.AbstractTime types, which includes NanoDates.jl. NanoDates.jl provides nanosecond-resolution timestamps at the cost of a larger memory footprint (16 bytes vs. 8 bytes compared to DateTime). The representable date range is -146138511-01-01T00:22:22 to 146138805-04-11T23:47:15.","category":"page"},{"location":"integrations/","page":"Integrations","title":"Integrations","text":"Example see 6NanoDatesintegration.jl.","category":"page"},{"location":"integrations/#Timestamps64.jl","page":"Integrations","title":"Timestamps64.jl","text":"","category":"section"},{"location":"integrations/","page":"Integrations","title":"Integrations","text":"Fastback provides seamless integration to all Dates.AbstractTime types, which includes Timestamps64.jl. Timestamps64.jl provides nanosecond-resolution timestamps without sacrificing performance. The Timestamp64 type has a smaller memory footprint (8 bytes vs. 16 bytes compared to NanoDate), and is faster for arithmetic operations. The representable date range is 1970-01-01T00:00:00 to 2262-04-11 23:47:16.","category":"page"},{"location":"integrations/","page":"Integrations","title":"Integrations","text":"Example see 7Timestamps64integration.md.","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"2. Portfolio trading","title":"2. Portfolio trading","text":"EditURL = \"../2_portfolio_trading.jl\"","category":"page"},{"location":"examples/gen/2_portfolio_trading/#Portfolio-trading-strategy-example","page":"2. Portfolio trading","title":"Portfolio trading strategy example","text":"","category":"section"},{"location":"examples/gen/2_portfolio_trading/","page":"2. Portfolio trading","title":"2. Portfolio trading","text":"This example demonstrates how to run a backtest with multiple assets, i.e. trading a portfolio of assets.","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"2. Portfolio trading","title":"2. Portfolio trading","text":"The price data is loaded from a CSV file containing daily close prices for the stocks AAPL, NVDA, TSLA, and GE, ranging from 2022-01-03 to 2024-04-22.","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"2. Portfolio trading","title":"2. Portfolio trading","text":"The strategy buys one stock if the last 5 days were positive, and sells it again if the last 2 days were negative. Each trade is executed at a commission of 0.1%.","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"2. Portfolio trading","title":"2. Portfolio trading","text":"When missing data points are detected for a stock, all open positions for that stock are closed. Logic of this type is common in real-world strategies and harder to implement in a vectorized way, showcasing the flexibility of Fastback.","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"2. Portfolio trading","title":"2. Portfolio trading","text":"The account equity, balance and drawdowns are collected for every day and plotted at the end using the Plots package. Additionally, the performance and P&L breakdown of each stock is plotted and statistics (avg. P&L, worst P&L, best P&L, win rate) are printed.","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"2. Portfolio trading","title":"2. Portfolio trading","text":"using Fastback\nusing Dates\nusing CSV\nusing DataFrames\n\ndata_path = \"../data/stocks_1d.csv\";\n\n# if data path doesn't exist, try to change working directory\nisfile(data_path) || cd(\"src/examples\")\n\n# load CSV daily stock data for symbols AAPL, NVDA, TSLA, GE\ndf_csv = DataFrame(CSV.File(data_path; dateformat=\"yyyy-mm-dd HH:MM:SS\"));\ndf_csv.symbol = Symbol.(df_csv.symbol); # convert string to symbol type\ndf = unstack(df_csv, :dt_close, :symbol, :close) # pivot long to wide format\nsymbols = Symbol.(names(df)[2:end]);\n\n# print summary\ndescribe(df)\n\n# create trading account with $10'000 start capital\nacc = Account();\ndeposit!(acc, Cash(:USD), 10_000.0);\n\n# register instruments for all symbols\ninstruments = map(sym -> Instrument(sym, sym, :USD), symbols);\nregister_instrument!.(Ref(acc), instruments);\n\n# data collector for account balance, equity and drawdowns (sampling every day)\ncollect_balance, balance_data = periodic_collector(Float64, Day(1));\ncollect_equity, equity_data = periodic_collector(Float64, Day(1));\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Day(1));\n\nfunction open_position!(acc, inst, dt, price)\n    # invest 20% of equity in the position\n    qty = 0.2equity(acc, :USD) / price\n    order = Order(oid!(acc), inst, dt, price, qty)\n    fill_order!(acc, order, dt, price; commission_pct=0.001)\nend\n\nfunction close_position!(acc, inst, dt, price)\n    # close position for instrument, if any\n    pos = get_position(acc, inst)\n    has_exposure(pos) || return\n    order = Order(oid!(acc), inst, dt, price, -pos.quantity)\n    fill_order!(acc, order, dt, price; commission_pct=0.001)\nend\n\n# loop over each row of DataFrame\nfor i in 6:nrow(df)\n    row = df[i, :]\n    dt = row.dt_close\n\n    # loop over all instruments and check strategy rules\n    for inst in instruments\n        price = row[inst.symbol]\n\n        window_open = @view df[i-5:i, inst.symbol]\n        window_close = @view df[i-2:i, inst.symbol]\n\n        # close position of instrument if missing data\n        if any(ismissing.(window_open))\n            close_price = get_position(acc, inst).avg_price\n            close_position!(acc, inst, dt, close_price)\n            continue\n        end\n\n        if !is_exposed_to(acc, inst)\n            # buy if last 5 days were positive\n            all(diff(window_open) .> 0) && open_position!(acc, inst, dt, price)\n        else\n            # close position if last 2 days were negative\n            all(diff(window_close) .< 0) && close_position!(acc, inst, dt, price)\n        end\n\n        # update position and account P&L\n        update_pnl!(acc, inst, price, price)\n    end\n\n    # close all positions at the end of backtest\n    if i == nrow(df)\n        for inst in instruments\n            price = row[inst.symbol]\n            close_position!(acc, inst, dt, price)\n        end\n    end\n\n    # collect data for plotting\n    if should_collect(equity_data, dt)\n        equity_value = equity(acc, :USD)\n        collect_balance(dt, cash_balance(acc, :USD))\n        collect_equity(dt, equity_value)\n        collect_drawdown(dt, equity_value)\n    end\nend\n\n# print account summary\nshow(acc)","category":"page"},{"location":"examples/gen/2_portfolio_trading/#Plot-account-balance,-equity,-drawdowns-and-stocks-performance","page":"2. Portfolio trading","title":"Plot account balance, equity, drawdowns and stocks performance","text":"","category":"section"},{"location":"examples/gen/2_portfolio_trading/","page":"2. Portfolio trading","title":"2. Portfolio trading","text":"using Plots, Query, Printf, Measures\n\ntheme(:juno; titlelocation=:left, titlefontsize=10, widen=false, fg_legend=:false)\n\n# equity / cash balance\np1 = plot(\n    dates(balance_data), values(balance_data);\n    title=\"Account\",\n    label=\"Cash balance\",\n    linetype=:steppost,\n    yformatter=:plain,\n    color=\"#0088DD\");\nplot!(p1,\n    dates(equity_data), values(equity_data);\n    label=\"Equity\",\n    linetype=:steppost,\n    color=\"#BBBB00\");\n\n# drawdowns\np2 = plot(\n    dates(drawdown_data), 100values(drawdown_data);\n    title=\"Equity drawdowns [%]\",\n    legend=false,\n    color=\"#BB0000\",\n    yformatter=y -> @sprintf(\"%.1f%%\", y),\n    linetype=:steppost,\n    fill=(0, \"#BB000033\"));\n\n# stocks performance\np3 = plot(\n    df.dt_close, df[!, 2] ./ df[1, 2];\n    title=\"Stocks performance (normalized)\",\n    yformatter=y -> @sprintf(\"%.1f\", y),\n    label=names(df)[2],\n    linetype=:steppost,\n    color=:green);\nfor i in 3:ncol(df)\n    plot!(p3,\n        df.dt_close, df[!, i] ./ df[1, i];\n        label=names(df)[i])\nend\n\n# P&L breakdown by stocks\npnl_by_inst = acc.trades |>\n              @groupby(_.order.inst.symbol) |>\n              @map({\n                  symbol = key(_),\n                  pnl = sum(getfield.(_, :realized_pnl))\n              }) |> DataFrame\np4 = bar(string.(pnl_by_inst.symbol), pnl_by_inst.pnl;\n    legend=false,\n    title=\"P&L breakdown by stocks [USD]\",\n    permute=(:x, :y),\n    xlims=(0, size(pnl_by_inst)[1]),\n    yformatter=y -> @sprintf(\"%.0f\", y),\n    color=\"#BBBB00\",\n    linecolor=nothing,\n    bar_width=0.5)\n\np = plot(p1, p2, p3, p4;\n    layout=@layout[a{0.4h}; b{0.15h}; c{0.3h}; d{0.15h}],\n    size=(800, 800), margin=0mm, left_margin=5mm);\np","category":"page"},{"location":"examples/gen/2_portfolio_trading/#Calculate-statistics-per-stock","page":"2. Portfolio trading","title":"Calculate statistics per stock","text":"","category":"section"},{"location":"examples/gen/2_portfolio_trading/","page":"2. Portfolio trading","title":"2. Portfolio trading","text":"Calculates summary statistics for each stock. Using the Query.jl package, all trades are first grouped by instrument symbol, then average P&L, worst P&L, best P&L, and win rate are calculated. Finally, the results are piped into a DataFrame and printed using the PrettyTables.jl package.","category":"page"},{"location":"examples/gen/2_portfolio_trading/","page":"2. Portfolio trading","title":"2. Portfolio trading","text":"using PrettyTables\n\ndf = acc.trades |>\n@groupby(_.order.inst.symbol) |>\n@map({\n    symbol = key(_),\n    avg_pnl = sum(getfield.(_, :realized_pnl)) / length(_),\n    worst_pnl = minimum(getfield.(_, :realized_pnl)),\n    best_pnl = maximum(getfield.(_, :realized_pnl)),\n    win_rate = round.(count(getfield.(_, :realized_pnl) .> 0) / count(is_realizing.(_)), sigdigits=2),\n}) |> DataFrame\n\npretty_table(df; column_labels=[\"Symbol\", \"Avg P&L\", \"Worst P&L\", \"Best P&L\", \"Win Rate\"])","category":"page"},{"location":"examples/gen/5_Tables_integration/","page":"5. Tables.jl integration","title":"5. Tables.jl integration","text":"EditURL = \"../5_Tables_integration.jl\"","category":"page"},{"location":"examples/gen/5_Tables_integration/#Tables.jl-integration-example","page":"5. Tables.jl integration","title":"Tables.jl integration example","text":"","category":"section"},{"location":"examples/gen/5_Tables_integration/","page":"5. Tables.jl integration","title":"5. Tables.jl integration","text":"This example demonstrates the Tables.jl integration in Fastback by running a simple backtest and then converting account data to DataFrames for display.","category":"page"},{"location":"examples/gen/5_Tables_integration/","page":"5. Tables.jl integration","title":"5. Tables.jl integration","text":"The Tables.jl interface provides zero-copy views of trades, positions, cash balances, equity balances, and collector output, making it easy to export results to DataFrames.jl, CSV.jl, Arrow.jl or any other package that consumes Tables-compatible sources.","category":"page"},{"location":"examples/gen/5_Tables_integration/","page":"5. Tables.jl integration","title":"5. Tables.jl integration","text":"using Fastback\nusing DataFrames\nusing Dates\nusing Random\n\n# set RNG seed for reproducibility\nRandom.seed!(123);\n\n# generate synthetic price series\nN = 500;\nprices = 100.0 .+ cumsum(randn(N) .* 0.5 .+ 0.05);\ndts = map(x -> DateTime(2021, 1, 1) + Hour(x), 0:N-1);\n\n# create trading account with $5'000 start capital and custom metadata types\nconst OrderMeta = NamedTuple{(:signal,),Tuple{String}}\nconst InstMeta = NamedTuple{(:sector,),Tuple{Symbol}}\n\nacc = Account(; odata=OrderMeta, idata=InstMeta);\ndeposit!(acc, Cash(:USD), 5_000.0);\n\n# register instruments with metadata\nAAPL = register_instrument!(acc, Instrument(Symbol(\"AAPL/USD\"), :AAPL, :USD; metadata=(sector=:tech,)));\nMSFT = register_instrument!(acc, Instrument(Symbol(\"MSFT/USD\"), :MSFT, :USD; metadata=(sector=:tech,)));\n\n# data collectors\ncollect_equity, equity_data = periodic_collector(Float64, Hour(12));\ncollect_drawdown, drawdown_data = drawdown_collector(DrawdownMode.Percentage, Hour(12));\n\n# simple momentum strategy\nprev_price = prices[1];\nfor (i, (dt, price)) in enumerate(zip(dts, prices))\n    global prev_price\n\n    # trade every 10 hours based on price momentum\n    if i % 10 == 0 && i > 10\n        momentum = (price - prev_price) / prev_price\n\n        if momentum > 0.02  # buy signal\n            quantity = 10.0\n            order = Order(oid!(acc), AAPL, dt, price, quantity; metadata=(signal=\"mom\",))\n            fill_order!(acc, order, dt, price; commission_pct=0.001)\n\n        elseif momentum < -0.02  # sell signal\n            quantity = -8.0\n            order = Order(oid!(acc), MSFT, dt, price, quantity; metadata=(signal=\"mom\",))\n            fill_order!(acc, order, dt, price; commission_pct=0.001)\n        end\n\n        prev_price = price\n    end\n\n    # update positions P&L\n    update_pnl!(acc, AAPL, price, price)\n    update_pnl!(acc, MSFT, price, price)\n\n    # collect equity data\n    if should_collect(equity_data, dt)\n        equity_value = equity(acc, :USD)\n        collect_equity(dt, equity_value)\n        collect_drawdown(dt, equity_value)\n    end\nend\n\n# print account summary\nshow(acc)","category":"page"},{"location":"examples/gen/5_Tables_integration/#Convert-trades-to-DataFrame","page":"5. Tables.jl integration","title":"Convert trades to DataFrame","text":"","category":"section"},{"location":"examples/gen/5_Tables_integration/","page":"5. Tables.jl integration","title":"5. Tables.jl integration","text":"df_trades = DataFrame(trades_table(acc))\n\nprintln(df_trades)","category":"page"},{"location":"examples/gen/5_Tables_integration/#Convert-positions-to-DataFrame","page":"5. Tables.jl integration","title":"Convert positions to DataFrame","text":"","category":"section"},{"location":"examples/gen/5_Tables_integration/","page":"5. Tables.jl integration","title":"5. Tables.jl integration","text":"df_positions = DataFrame(positions_table(acc))\n\nprintln(df_positions)","category":"page"},{"location":"examples/gen/5_Tables_integration/#Convert-cash-balances-to-DataFrame","page":"5. Tables.jl integration","title":"Convert cash balances to DataFrame","text":"","category":"section"},{"location":"examples/gen/5_Tables_integration/","page":"5. Tables.jl integration","title":"5. Tables.jl integration","text":"df_balances = DataFrame(balances_table(acc))\n\nprintln(df_balances)","category":"page"},{"location":"examples/gen/5_Tables_integration/#Convert-equity-balances-to-DataFrame","page":"5. Tables.jl integration","title":"Convert equity balances to DataFrame","text":"","category":"section"},{"location":"examples/gen/5_Tables_integration/","page":"5. Tables.jl integration","title":"5. Tables.jl integration","text":"df_equities = DataFrame(equities_table(acc))\n\nprintln(df_equities)","category":"page"},{"location":"examples/gen/5_Tables_integration/#Convert-equity-collector-data-to-DataFrame","page":"5. Tables.jl integration","title":"Convert equity collector data to DataFrame","text":"","category":"section"},{"location":"examples/gen/5_Tables_integration/","page":"5. Tables.jl integration","title":"5. Tables.jl integration","text":"df_equity_history = DataFrame(equity_data)\n\nprintln(df_equity_history)","category":"page"},{"location":"examples/gen/5_Tables_integration/#Convert-balance-collector-data-to-DataFrame","page":"5. Tables.jl integration","title":"Convert balance collector data to DataFrame","text":"","category":"section"},{"location":"examples/gen/5_Tables_integration/","page":"5. Tables.jl integration","title":"5. Tables.jl integration","text":"df_drawdown_history = DataFrame(drawdown_data)\n\nprintln(df_drawdown_history)","category":"page"},{"location":"#Fastback.jl-Blazingly-fast-Julia-backtester","page":"Home","title":"Fastback.jl - Blazingly fast Julia backtester 🚀","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: License) (Image: Maintenance) (Image: Documentation)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fastback provides a lightweight, flexible and highly efficient event-based backtesting library for quantitative trading strategies.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main value of Fastback is provided by the account and bookkeeping implementation. It keeps track of the open positions, account balance and equity. Furthermore, the execution logic supports commissions, slippage, partial fills and execution delays in its design.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fastback does not try to model every aspect of a trading system, e.g. brokers, data sources, logging etc. Instead, it provides basic building blocks for creating a custom backtesting environment that is easy to understand and extend. For example, Fastback has no notion of \"strategy\" or \"indicator\", such constructs are highly strategy specific, and therefore up to the user to define.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The event-based architecture aims to mimic the way a real-world trading systems works, where new data is ingested as a continuous data stream, i.e. events. This reduces the implementation gap from backtesting to real-world execution significantly compared to a vectorized backtesting frameworks.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Event-based, modular architecture\nMulti-currency support\nHold multiple cash assets in parallel, e.g. USD, EUR, BTC etc.\nTrade instruments with different quote currencies corresponding to the account currencies\nHelpers for currency conversion\nSupports arbitrary price data sources\nSupports modelling commissions, execution delays, price slippage and partial fills\nFlexible data collectors to historize account balances, drawdowns, etc.\nFacilities for parallelized backtesting and hyperparameter optimization\nUses position netting approach for bookkeeping\nMaintains single position per instrument using weighted average cost method\nAbility to attach arbirary metadata to instruments and orders in type-safe manner\nIntegrations\nTables.jl integration for Account related data like trades, positions, balances, etc.\nNanoDates.jl integration for nanosecond-resolution timestamps\nTimestamps64.jl integration for more efficient nanosecond-resolution timestamps","category":"page"},{"location":"#Documentation-and-Examples","page":"Home","title":"Documentation & Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Full documentation and examples are available at Fastback.jl documentation page.","category":"page"},{"location":"#Changelog","page":"Home","title":"Changelog","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the CHANGELOG.","category":"page"},{"location":"#Bug-reports-and-feature-requests","page":"Home","title":"Bug reports and feature requests","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please report any issues via the GitHub issue tracker.","category":"page"}]
}
